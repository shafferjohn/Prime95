; Copyright 2011-2023 - Mersenne Research, Inc.  All rights reserved
; Author:  George Woltman
; Email: woltman@alum.mit.edu
;
; These macros do the first pass of an AVX primarily radix-4 DJB "r4dwpn" FFT.
;

;; IDEA:  Use prefetchnta to tell CPU when data will no longer be used? (sg4cl and sg8cl forward FFT macros)
;; IDEA:  For larger clms and FFT sizes prefetch to L3 rather than L2???  Apparently not beneficial on Sandy Bridge.


; ********************************************************
; ********************************************************
; ******************  PASS 1 MACROS  *********************
; ********************************************************
; ********************************************************

;;
;; Estimated memory requirements for each real pass 1 macro:
;;
;; Pass 1 size:			128	256	320	384	448	512	640	768	896	1024	1280	1536	1792	2048
;;
;; FFT data:			16K	32K	40K	48K	56K	64K	80K	96K	112K	128K	160K	192K	224K	256K
;; Scratch size:		16K	32K	40K	48K	56K	64K	80K	96K	112K	128K	160K	192K	224K	256K
;; Variable sin/cos data:	10.75K	14.75K	16.75K	18.75K	20.75K	22.75K	33.5K	22.75K	41.5K	45.5K	32.75K	30.75K	43.5K	45.5K
;; Fixed sin/cos data:		0.75K	1.5K	4.5K	5K	6.5K	6K	9K	5.25K	13K	16K	18K	18K	26K	32K
;; Carry data:			1K	2K	2.5K	3K	3.5K	4K	5K	6K	7K	8K	10K	12K	14K	16K
;; Normalization data:		2.5K	2.5K	6.25K	7.5K	8.75K	10K	6.25K	15K	8.75K	10K	25K	30K	17.5K	20K
;; Big/lit flags:		0.5K	1K	1.25K	1.5K	1.75K	2K	2.5K	3K	3.5K	4K	5K	6K	7K	8K
;; Data prefetched early:	8K	16K	26K	32K	42K	40K	52K	52K	84K	80K	139K	131K	172K	175K
;;
;; Min L2 cache size (clm=4):	86K	151.5K	189.25K	216.5K	252.75K	283K	366K	408.75K	488K	550K	611K	723K	879.5K	928K
;;     L2 cache size (clm=2):		79K	103.13K	118.25K	138.38K	154.5K	193.75K	220.5K	259.25K	293K	327K	400.5K	461.5K	488.5K
;;     L2 cache size (clm=1):		43K	60K	69.13K	81.25K	90.25K	107.63K	123.75K	144.88K	164.5K	185K	239.25K	252.5K	270.25K
;;
;; NOTE:  To calculate the minimum efficient L2 cache size, we double the
;; data and variable sin/cos data sizes as both the current data
;; and next block data will be in the cache at the same time.  Any data
;; prefetched early (during the inverse FFT process) runs the danger of
;; pushing out the fixed sin/cos data and normalization data because of the
;; LRU cache-eviction algorithm.  The L2 cache size formula is:
;;	(FFT data size + Variable sin/cos data) * 2 +
;;	(Scratch size + Fixed sin/cos data + Normalization data + big/lit data) +
;;	(amount of data prefetched during inverse FFT process)
;; ALSO NOTE:  Numbers above are for clm = 4.  Clm affects the FFT data size,
;; scratch size, variable sin/cos size, big/lit flags, and data prefetched early.

;; Estimated memory requirements for each negacyclic pass 1 macro:
;;
;; Pass 1 size:			128	256	384	512	640	768	1024	1280	1536	2048
;;
;; FFT data:			16K	32K	48K	64K	80K	96K	128K	160K	192K	256K
;; Scratch size:		16K	32K	48K	64K	80K	96K	128K	160K	192K	256K
;; Variable sin/cos data:	7.25K	14.5K	11.25K	15.25K	15.25K	22.5K	30.5K	30.5K	23.25K	31K
;; Fixed sin/cos data:		5K	5K	9K	12K	15K	18K	24K	30K	39K	52K
;; Normalization data:		5K	5K	15K	20K	25K	15K	20K	25K	60K	20K
;; Big/lit flags:		0.5K	1K	1.5K	2K	2.5K	3K	4K	5K	6K	8K
;; Data prefetched early:	8K	16K	32K	40K	44K	64K	80K	88K	144K	128K
;;
;; Min L2 cache size (clm=4):	82.5K	147K	205.5K	274K	324.5K	396K	528K	624K	729K	916K
;;     L2 cache size (clm=2):	46.25K	78.5K	114.75K	153K	182.25K	214.5K	286K	339.5K	414K	494K
;;     L2 cache size (clm=1):		44.25K	69.38K	92.5K	111.13K	123.75K	165K	197.25K	256.5K	283K


;; Constant to control when we group pass 1 sections.  Sandy Bridge CPUs have a 32KB L1 data cache.
;; We're guessing grouping isn't necessary when pass 1 data is less than 24KB.  We need to tune this!

GROUPING_SIZE = 24*1024 *1000
CLM_GROUPING = 1

;;***********************************************************************
;; Pass 1 macros
;;
;; p2cl = number of 128-byte cache lines processed from a pass 2 block
;; clm = cache line multiplier (num cache lines processed each iteration)
;;***********************************************************************

; Note:  All memory layouts are for 64 byte cache lines.


IFDEF YIMPL_WPN1_FFTS

;; Perform a pass 1 FFT of length 128 doubles.
;; Memory examples are for a 128K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 4*clm*YMM_SCD4 = 43*clm 64-byte cache lines

yr4dwpn_pass1sc128 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7b, b8b, b9b, c0b, c1b, c6b, c7b, c8b, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 128, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 128K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 15 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 3.75 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR		;; Get source address
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdx, PREMULT_ADDR	;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]	;; Complex data sin/cos ptr
pfing	lea	rcx, [rdx+(43-16)*clm*64] ;; Finish prefetching the sin/cos/premult data
	yloop_init 4*4*clm		;; 4*4*clm iterations
	yloop_set_prefetch YSINGLE	;; Prefetch 16*clm cache lines
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sine/cosine ptr

	loops_reset
	yloop_set_prefetch YSINGLE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sine/cosine ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4 ;; Loop, next premult/sin/cos pointer
	yloop	2, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9b, -2*clmblkdst8	;; Loop, restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 12 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 3 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c7b, -2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 16
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 16

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 8*4*blkdst		;; We've already prefetched 8 blocks
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 12 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 3 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + clm*YMM_SCD2 + 4*clm*YMM_SCD4 ;; sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 4*4*clm			;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7b,	-2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 15 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 3.75 macros each processing 32 data values

	start_timer 26
	bump	rdi, -4*clm*16-4*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YDOUBLE
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore premult/sine/cosine ptr

	loops_reset
	yloop_set_prefetch YDOUBLE		;; Prefetch 32*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore premult/sine/cosine ptr
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Loop, next premult/sine/cosine pointer
	yloop	2, b9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b9b				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 128 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 128 doubles.
;; Memory examples are for a 128K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*16 + 4*clm*YMM_SCND2 + 4*clm*YMM_SCD4 = 29*clm 64-byte cache lines

yr4dwpn_pass1sc128ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b7b, b9b, c0b, c1b, c7b, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 128, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 128K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 16 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR		;; Get source address
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, PREMULT_ADDR	;; Load premult/sin/cos pointer
pfing	lea	rcx, [rdi+(29-16)*clm*64] ;; Finish prefetching the sin/cos/premult data
	yloop_init 4*4*clm		;; 4*4*clm iterations
	yloop_set_prefetch YSINGLE	;; Prefetch 16*clm cache lines
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos data pointer
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4 ;; Test loop counter, next premult/sin/cos pointer
	yloop	2, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9b, -2*clmblkdst8	;; Loop, restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c7b,	-2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...

;; Do 16 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 16
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 16

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 four_complex_first_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 8*4*blkdst		;; We've already prefetched 8 blocks
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 16 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCD4
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 16 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 32 data values

	start_timer 26
	bump	rdi, -4*clm*16-4*clm*YMM_SCD4	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_prefetch YSINGLE		;; Prefetch 16*clm cache lines
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b9b				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 128 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 256 doubles.
;; Memory examples are for a 256K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*16 + 2*4*clm*YMM_SCND4 + clm*YMM_SCD4 + 4*clm*YMM_SCD8 = 86*clm 64-byte cache lines

IFDEF OLD_WAY
yr4dwpn_pass1sc256 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7b, b8b, b9b, c0b, c1b, c6b, c7b, c8b, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 256, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 256K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7,8
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 15 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 3.75 macros each processing 64 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR		;; Get source address
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdx, PREMULT_ADDR	;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD4]	;; Complex data sin/cos ptr
pfing	lea	rcx, [rdx+(86-32)*clm*64] ;; Finish prefetching the sin/cos/premult data
	yloop_init 4*4*clm		;; 4*4*clm iterations
	yloop_set_prefetch YDOUBLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/source ptrs, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YDOUBLE	;; Prefetch 32*clm cache lines
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/source ptrs, restore premult/sine/cosine pointer
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Loop, next dest pointer, next premult/sin/cos pointer
	yloop	4, c9b, -4*clmblkdst8	;; Loop, restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 24 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 6 macros each processing 32 data values

	start_timer 17
	bump	rdi, 2*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*8]		;; Sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 8*4*clm			;; 8*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	 ;; 4*clm iterations
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	 ;; 4*clm iterations
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, restore sin/cos pointers
	yloop	4, c7b, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...

;; Do 32 eight_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 8 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 32
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 32

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 16*4*blkdst	;; We've already prefetched 16 blocks
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 8 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst	;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 24 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 6 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*16 + clm*YMM_SCD4 + 4*clm*YMM_SCD8 ;; sin/cos ptr
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 8*4*clm			;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; 4*clm iterations
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; 4*clm iterations
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, restore sin/cos ptrs
	yloop	4, b7b,	-4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 15 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 3.75 macros each processing 64 data values

	start_timer 26
	bump	rdi, -2*4*clm*16-4*clm*YMM_SCD8	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD4]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YDOUBLE
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YDOUBLE		;; Prefetch 32*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Loop, next source pointer, next premult/sine/cosine pointer
	yloop	4, b9b			;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 256 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF

;; Perform a pass 1 FFT of length 256 doubles.
;; Memory examples are for a 256K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 = 59*clm 64-byte cache lines

yr4dwpn_pass1sc256 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7b, b8b, b9b, c0b, c1b, c6b, c7b, c8b, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 256, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 256K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 31 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR		;; Get source address
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdx, PREMULT_ADDR	;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]	;; Complex data sin/cos ptr
pfing	lea	rcx, [rdx+(59-32)*clm*64] ;; Finish prefetching the sin/cos/premult data
	yloop_init 8*4*clm		;; 8*4*clm iterations
	yloop_set_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sine/cosine ptr

	loops_reset
	yloop_set_prefetch YSINGLE	;; Prefetch 32*clm cache lines
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sine/cosine ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4 ;; Loop, next premult/sin/cos pointer
	yloop	2, c9b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	4, c9b, -4*clmblkdst8	;; Loop, restore source pointer
	end_timer 16

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 28 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 7 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 8*4*clm			;; 8*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	4, c7b, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...

;; Do 32 sixteen_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 4 macros each processing 64 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 32
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 32

;; Do FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 sixteen_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 64 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 16*4*blkdst	;; We've already prefetched 16 blocks
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iters prefetching 8*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 28 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 7 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 ;; sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 8*4*clm			;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, b7b,	-4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 31 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 32 data values

	start_timer 26
	bump	rdi, -4*clm*16-8*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 8*4*clm			;; 8 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YSINGLE
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore premult/sine/cosine ptr

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 32*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore premult/sine/cosine ptr
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Loop, next premult/sine/cosine pointer
	yloop	2, b9b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	4, b9b				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 256 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 256 doubles.
;; Memory examples are for a 256K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*16 + 2*4*clm*YMM_SCND2 + 4*clm*YMM_SCD8 = 58*clm 64-byte cache lines

yr4dwpn_pass1sc256ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b7b, b9b, c0b, c1b, c7b, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 256, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 256K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 16 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 64 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR		;; Get source address
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, PREMULT_ADDR	;; Load premult/sin/cos pointer
pfing	lea	rcx, [rdi+(58-32)*clm*64] ;; Finish prefetching the sin/cos/premult data
	yloop_init 4*4*clm		;; 4*4*clm iterations
	yloop_set_prefetch YDOUBLE	;; Prefetch 8 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos data pointer
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -4*clmblkdst8	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 17
	bump	rdi, 2*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*8]		;; Sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 8*4*clm			;; 8*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND2 ;; Loop, restore sin/cos pointers
	yloop	4, c7b,	-4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...

;; Do 32 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 8 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 32
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 32

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 four_complex_first_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 16*4*blkdst	;; We've already prefetched 16 blocks
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 8 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst	;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 32 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*16 + 4*clm*YMM_SCD8
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 8*4*clm			;; 8 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND2 ;; Loop, restore sin/cos ptrs
	yloop	4, b7b, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 16 eight_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 64 data values

	start_timer 26
	bump	rdi, -2*4*clm*16-4*clm*YMM_SCD8	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YDOUBLE		;; Prefetch 32*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 256 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 320 doubles.
;; Memory examples are for a 320K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 10*clm*YMM_SCD4 = 67*clm 64-byte cache lines

;; This pass processes 160*clm cache lines, or 40KB if clm=4, suggesting we should use clm=4:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc320 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9b, c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 320, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 320K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 39 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 36 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 9 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (40*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 10*4*clm			;; 10*4*clm iterations
	lea	rbx, [rdi+10*clm*YMM_SCD4+4*clm*16] ;; Sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst, rdi, clm*YMM_SCD4 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 9 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	5, c9a, -5*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 10*4*clm			;; 10*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	2, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	5, c9b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 10*4*clm			;; 10*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 9 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	5, c7b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...

;; Do 16 twenty_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 80 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 40
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 40

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 80 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, (27-3)*4*blkdst	;; We've already prefetched 27 blocks which will be 3 too many
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	4, b1b, -4*clmblkdst ;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 36 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 9 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 39 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (40*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD2		;; Complex data sin/cos ptr
	lea	rdx, [rbx+10*clm*YMM_SCD4]	;; Premultiplier/sin/cos ptr
	lea	rdi, [rdx+4*clm*16]		;; Premultiplier/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 10*4*clm			;; 10 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 36*clm cache lines
	yloop_set_alternate_prefetch_increment 67, (36+39)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Loop, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 39*clm cache lines
	yloop_set_alternate_prefetch_increment 67, (36+39)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next src/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + clm*YMM_SCD2 + 10*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 10*4*clm			;; 10 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 36*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b7b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-10*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 10*4*clm			;; 10 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 39*clm cache lines
pfing	bump	rcx, (67-36-39)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter
	yloop	5, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 320 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 384 doubles.
;; Memory examples are for a 384K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD2 + 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 4*clm*YMM_SCD4 = 75*clm 64-byte cache lines

;; This pass processes 192*clm cache lines, or 48KB if clm=4, suggesting we should use clm=4:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

IFDEF OLD_WAY
yr4dwpn_pass1sc384 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 384, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 384K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 47 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 44 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 11 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 12*4*clm			;; 12*4*clm iterations
	lea	rbx, [rdi+4*clm*YMM_SCD4+4*clm*16] ;; Second sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	yloop	3, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	4, c9a, -12*4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCND4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	12, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	4, c9b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	12, c7b, -12*4*clmblkdst, rdi, 4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 16 six_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 24 data values
;; Do 48 three_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 24 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...

;; Do 48 eight_reals_unfft operations
;;	distance between fft data elements is 48K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+9 cache lines of s/c data.
;; A grand total of 16448 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 16*4*clm			;; 16 or 12 iters of 4*clm

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr3_3cl_csc_six_reals_unfft_preload
c4b:	yr3_3cl_csc_six_reals_unfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+12*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+12*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; Test loop counter
	yloop	4, c5b, -4*12*clmblkdst, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbx, 4*YMM_SCD3 ;; Test loop counter
	yloop	4, c1b, -3*4*clmblkdst+clmblkdst, rbx, -3*4*YMM_SCD3+YMM_SCD3 ;; 3 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YHALF
	yr3_3cl_csc_six_reals_unfft_preload
c4b:	yr3_3cl_csc_six_reals_unfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; 4 iterations, restore sine/cosine pointer
	yloop	4, c5b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 12*4*clm			;; 12 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	12, c1b				;; Test loop counter
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 48
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 48

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 48 eight_reals_fft operations
;;	distance between fft data elements is 48K
;;	do 12 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 six_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 24 data values
;; Do 48 three_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 9+8*clm cache lines of s/c data.
;; A grand total of 16448 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 32*4*blkdst		;; We've already prefetched 32 blocks

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rbx, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 4*clm*YMM_SCD4 ;; Create second sin/cos ptr
	yloop_init 16*4*clm			;; 12 or 16 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -3*4*clmblkdst, rdi, -3*4*YMM_SCD3+YMM_SCD3 ;; Loop 3 times!! restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YQUARTER
	yr3_3cl_csc_six_reals_fft_preload
b4b:	yr3_3cl_csc_six_reals_fft rsi, 64, 4*clmblkdst, rbx, YMM_SCD2, 4*clm
	yloop	4*clm, b4b, -4*clm*64+12*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rbx, YMM_SCD2, 4*clm
	yloop	4*clm, b5b, -4*clm*64+12*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations
	yloop	4, b5b, -4*12*clmblkdst+clmblkdst, rbx, 4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx-4*4*clm*YMM_SCD2]	;; Restore sin/cos ptr

ELSE

	start_timer 22
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	12, b1b, -12*clmblkdst		;; Loop, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 4*clm*YMM_SCD4 ;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YQUARTER
	yr3_3cl_csc_six_reals_fft_preload
b4b:	yr3_3cl_csc_six_reals_fft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b4b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 44 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 11 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 47 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, -4*clm*YMM_SCND4		;; Premultiplier/sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-4*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 44*clm cache lines
	yloop_set_alternate_prefetch_increment 75, (44+47)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
	yloop_set_alternate_prefetch_increment 75, (44+47)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	3, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	bump	rdi, -4*clm*YMM_SCND4		;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 44*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-4*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer

	loops_reset
pfing	bump	rcx, (75-44-47)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer
	yloop	12, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 384 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF

;; Perform a pass 1 FFT of length 384 doubles.
;; Memory examples are for a 384K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 12*clm*YMM_SCD4 = 75*clm 64-byte cache lines

;; This pass processes 192*clm cache lines, or 48KB if clm=4, suggesting we should use clm=4:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc384 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 384, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 384K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 47 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 44 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 11 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 12*4*clm			;; 12*4*clm iterations
	lea	rbx, [rdi+12*clm*YMM_SCD4+4*clm*16] ;; Second sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst, rdi, clm*YMM_SCD4 ;; Test loop counter, restore scratch area pointer, next sin/cos ptr
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, c9a, -6*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	2, c9b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, c9b, -6*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, c7b, -6*clmblkdst8		;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...

;; Do 16 twenty_four_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 96 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 48
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 48

;; Do FFT levels 1,2,3,4,5 (actually 4.565 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_four_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 96 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 32*4*blkdst		;; We've already prefetched 32 blocks
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst		;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 44 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 11 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 47 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD2		;; Complex data sin/cos ptr
	lea	rdx, [rbx+12*clm*YMM_SCD4]	;; Premultiplier/sin/cos ptr
	lea	rdi, [rdx+4*clm*16]		;; Premultiplier/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 12*4*clm			;; 12 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 44*clm cache lines
	yloop_set_alternate_prefetch_increment 75, (44+47)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
	yloop_set_alternate_prefetch_increment 75, (44+47)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + clm*YMM_SCD2 + 12*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 44*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, restore source pointer
	yloop	6, b7b, -6*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-12*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer

	loops_reset
pfing	bump	rcx, (75-44-47)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 384 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 384 doubles.
;; Memory examples are for a 384K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD1 + 4*clm*16 + 4*clm*YMM_SCND2 + 4*clm*YMM_SCD4 = 45*clm 64-byte cache lines

;; This pass processes 192*clm cache lines, or 48KB if clm=4, suggesting we should use clm=4:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc384ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 384, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 384K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 48 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 12 macros each processing 32 data values

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD4+4*clm*16] ;; Load second premult/sin/cos pointer
	yloop_init 12*4*clm			;; 12*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	3, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -12*4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCND2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	12, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	12, c7b, -12*4*clmblkdst, rdi, 4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 64 three_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 24 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...

;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 48K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4*clm+18 cache lines of s/c data.
;; A grand total of 16000 bytes with clm=4 -- easily fits in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16 or 12 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+12*clmblkdst, rdi, -4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, c5b, -4*12*clmblkdst, rdi, 4*clm*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -3*4*clmblkdst+clmblkdst, rbp, -3*4*YMM_SCD6+YMM_SCD6 ;; Loop 3 times!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter, restore source pointer

ELSE

	start_timer 18
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 12*4*clm			;; 12 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	12, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 48
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 48

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 48 four_complex_first_fft operations
;;	distance between fft data elements is 48K
;;	do 12 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 three_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 18+4*clm cache lines of s/c data.
;; A grand total of 16000 bytes with clm=4 -- easily fits in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 32*4*blkdst		;; We've already prefetched 32 blocks

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 4*clm*16 + 4*clm*YMM_SCND2 + 4*clm*YMM_SCD4
	yloop_init 16*4*clm			;; 12 or 16 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -3*4*clmblkdst, rdi, -3*4*YMM_SCD6+YMM_SCD6 ;; 3 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rbp, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+12*clmblkdst, rbp, -4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, b5b, -4*12*clmblkdst+clmblkdst, rbp, 4*clm*YMM_SCD1 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-4*4*clm*YMM_SCD1-4*clm*YMM_SCND2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	12, b1b, -12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND2 + 4*clm*YMM_SCD4
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -4*clm*YMM_SCND2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 12 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-4*clm*YMM_SCD4]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
	yloop_set_alternate_prefetch_increment 45, (24+24)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
	yloop_set_alternate_prefetch_increment 45, (24+24)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	3, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_prefetch YHALF
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-4*clm*YMM_SCD4	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
pfing	bump	rcx, (45-24-24)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	12, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 384 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 448 doubles.
;; Memory examples are for a 448K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 14*clm*YMM_SCD4 = 83*clm 64-byte cache lines

;; This pass processes 224*clm cache lines, or 56KB if clm=4, suggesting we should use clm=4:  56KB of scratch area, 56KB of input FFT data,
;; 56KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc448 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9b, c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 448, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 448K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 55 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 52 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 13 macros each processing 32 data values

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (56*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 14*4*clm			;; 14*4*clm iterations
	lea	rbx, [rdi+14*clm*YMM_SCD4+4*clm*16] ;; Sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 14 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst, rdi, clm*YMM_SCD4 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 13 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	7, c9a, -7*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 14*4*clm			;; 14*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 14 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	2, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	7, c9b, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 14*4*clm			;; 14*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 13 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	7, c7b, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	224K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	220K	...

;; Do 16 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 112 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 56
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 56

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	224K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	220K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 112 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, (43-3)*4*blkdst	;; We've already prefetched 43 blocks which will be 3 too many
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 52 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 13 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 55 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (56*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD2		;; Complex data sin/cos ptr
	lea	rdx, [rbx+14*clm*YMM_SCD4]	;; Premultiplier/sin/cos ptr
	lea	rdi, [rdx+4*clm*16]		;; Premultiplier/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 14*4*clm			;; 14 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 52*clm cache lines
	yloop_set_alternate_prefetch_increment 83, (52+55)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 55*clm cache lines
	yloop_set_alternate_prefetch_increment 83, (52+55)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	7, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + clm*YMM_SCD2 + 14*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 14*4*clm			;; 14 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 52*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	7, b7b, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-14*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 14*4*clm			;; 14 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 55*clm cache lines
pfing	bump	rcx, (83-52-55)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	7, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 448 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 512 doubles.
;; Memory examples are for a 512K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 = 91*clm 64-byte cache lines

;; This pass processes 256*clm cache lines, or 64KB if clm=4, suggesting we should use clm=4:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc512 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 512, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 512K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 63 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 60 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 15 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16*4*clm iterations
	lea	rbx, [rdi+16*clm*YMM_SCD4+4*clm*16] ;; Sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst, rdi, clm*YMM_SCD4 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	2, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	8, c9b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	8, c7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...

;; Do 64 eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+12 cache lines of s/c data.
;; A grand total of 19200 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rdi+16*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+2*clmblkdst8 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+2*clmblkdst8 ;; Test loop counter
	yloop	4, c5b, -4*2*clmblkdst8, rbx, YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 18
	loops_undo 4*4*clm

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD3 ;; Test loop counter
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c1b, -2*clmblkdst8+clmblkdst, rdi, -4*4*YMM_SCD3+YMM_SCD3 ;; 2 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 16*YMM_SCD3		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations

	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sine/cosine pointer
	yloop	4, c5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -16*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 64
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 64

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 12+4 cache lines of s/c data.
;; A grand total of 19200 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 40*4*blkdst		;; We've already prefetched 40 blocks

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+16*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, b1b, -2*clmblkdst8, rdi, -4*4*YMM_SCD3+YMM_SCD3 ;; 2 iterations, restore source pointer, next sin/cos ptr
	loops_undo 2*2*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b4b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YHALF
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*2*clmblkdst8+clmblkdst, rbx, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3	;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 60 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 15 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 63 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD2		;; Complex data sin/cos ptr
	lea	rdx, [rbx+16*clm*YMM_SCD4]	;; Premultiplier/sin/cos ptr
	lea	rdi, [rdx+4*clm*16]		;; Premultiplier/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YHALF		;; Prefetch 30*clm cache lines
	yloop_set_alternate_prefetch_increment 91, (30+63)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
	yloop_set_alternate_prefetch_increment 91, (30+63)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 30*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-16*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
pfing	bump	rcx, (91-30-63)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	8, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 512 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 512 doubles.
;; Memory examples are for a 512K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD2 + 4*clm*16 + 4*clm*YMM_SCND2 + 4*clm*YMM_SCD4 = 61*clm 64-byte cache lines

;; This pass processes 256*clm cache lines, or 64KB if clm=4, suggesting we should use clm=4:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc512ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 512, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 512K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 64 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD4+4*clm*16] ;; Load second premult/sin/cos pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND2, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCND2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	8, c7b, -8*clmblkdst8, rdi, 4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+2*clmblkdst8, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, c5b, -4*2*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, c1b, -2*clmblkdst8+clmblkdst, rbp, -4*4*YMM_SCD6+YMM_SCD6 ;; 2 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 64
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 64

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 four_complex_first_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 24+8*clm cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 40*4*blkdst		;; We've already prefetched 40 blocks

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 4*clm*16 + 4*clm*YMM_SCND2 + 4*clm*YMM_SCD4
	yloop_init 16*4*clm			;; 16 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, b1b, -2*clmblkdst8, rdi, -4*4*YMM_SCD6+YMM_SCD6 ;; 2 iterations, restore source ptr, next sin/cos ptr
	loops_undo 2*2*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rbp, YMM_SCD2, 4*clm
	yloop	4*clm, b5b, -4*clm*64+2*clmblkdst8, rbp, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, b5b, -4*2*clmblkdst8+clmblkdst, rbp, 4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-4*4*clm*YMM_SCD2-4*clm*YMM_SCND2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND2 + 4*clm*YMM_SCD4
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -4*clm*YMM_SCND2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 16 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-4*clm*YMM_SCD4]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 32*clm cache lines
	yloop_set_alternate_prefetch_increment 61, (32+32)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	yloop_set_prefetch YHALF		;; Prefetch 32*clm cache lines
	yloop_set_alternate_prefetch_increment 61, (32+32)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_prefetch YHALF
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-4*clm*YMM_SCD4	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (61-32-32)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 512 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 640 doubles.
;; Memory examples are for a 640K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD4 + 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 4*clm*YMM_SCD4 = 107*clm 64-byte cache lines

;; This pass processes 320*clm cache lines, or 80KB if clm=4, suggesting we should use clm=4:  80KB of scratch area, 80KB of input FFT data,
;; 80KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

IFDEF INFERIOR
;; I haven't timed this in quite a while.  I should retry it in a 4 worker situation where we are memory bandwidth limited.
;;  IDEA:  Try 20 fixed sections rather than 4.  Same mem consumption, but may or may not be faster.

yr4dwpn_pass1sc640 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 640, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 640K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 79 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 19.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 76 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 19 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 20*4*clm			;; 20*4*clm iterations
	lea	rbx, [rdi+4*clm*YMM_SCD4+4*clm*16] ;; Second sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	yloop	5, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	4, c9a, -20*4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCND4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	20, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	4, c9b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	20, c7b, -20*4*clmblkdst, rdi, 4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...

;; Do 16 ten_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 40 data values
;; Do 48 five_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 40 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K	...

;; Do 80 eight_reals_unfft operations
;;	distance between fft data elements is 80K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 16*clm+15 cache lines of s/c data.
;; A grand total of 28096 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 32*4*clm			;; 16 or 20 iters of 4*clm

c4a:	start_timer 18
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YQUARTER
	yr5_5cl_csc_ten_reals_unfft_preload
c4b:	yr5_5cl_csc_ten_reals_unfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+20*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+20*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter
	yloop	8, c5b, -4*20*clmblkdst, rdi, 4*clm*YMM_SCD4 ;; 4 iterations!! Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rbx, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbx, 4*YMM_SCD3 ;; Test loop counter
	yloop	8, c1b, -5*4*clmblkdst+clmblkdst, rbx, -5*4*YMM_SCD3+YMM_SCD3 ;; 5 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YQUARTER
	yr5_5cl_csc_ten_reals_unfft_preload
c4b:	yr5_5cl_csc_ten_reals_unfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+20*clmblkdst, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+20*clmblkdst, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sine/cosine pointer
	yloop	4, c5b, -4*20*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	20, c1b				;; Test loop counter
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 80
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 80

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...

;; Do 80 eight_reals_fft operations
;;	distance between fft data elements is 80K
;;	do 20 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 ten_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 40 data values
;; Do 48 five_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 40 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 15+16*clm cache lines of s/c data.
;; A grand total of 28096 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 44*4*blkdst		;; We've already prefetched 44 blocks

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rbx, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 4*clm*YMM_SCD4 ;; Create second sin/cos ptr
	yloop_init 32*4*clm			;; 20 or 16 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -5*4*clmblkdst, rdi, -5*4*YMM_SCD3+YMM_SCD3 ;; Loop 5 times!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE
	yr5_5cl_csc_ten_reals_fft_preload
b4b:	yr5_5cl_csc_ten_reals_fft rsi, 64, 4*clmblkdst, rbx, YMM_SCD4, 4*clm
	yloop	4*clm, b4b, -4*clm*64+20*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, 4*clmblkdst, rbx, YMM_SCD4, 4*clm
	yloop	4*clm, b5b, -4*clm*64+20*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations
	yloop	8, b5b, -4*20*clmblkdst+clmblkdst, rbx, 4*clm*YMM_SCD4 ;; 4 iterations!! next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx-4*4*clm*YMM_SCD4]	;; Restore sin/cos ptr

ELSE

	start_timer 22
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	20, b1b, -20*clmblkdst		;; Loop, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 4*clm*YMM_SCD4 ;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr5_5cl_csc_ten_reals_fft_preload
b4b:	yr5_5cl_csc_ten_reals_fft rsi, 64, 4*clmblkdst, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b4b, -4*clmblkdst+20*clmblkdst, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+20*clmblkdst, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 76 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 19 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 79 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 19.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, -4*clm*YMM_SCND4		;; Premultiplier/sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-4*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 76*clm cache lines
	yloop_set_alternate_prefetch_increment 107, (76+40)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YHALF		;; Prefetch 40*clm cache lines
	yloop_set_alternate_prefetch_increment 107, (76+40)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	5, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	bump	rdi, -4*clm*YMM_SCND4		;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 76*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	20, b7b, -20*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-4*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer

	loops_reset
pfing	bump	rcx, (107-76-40)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF		;; Prefetch 40*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	20, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 640 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF


;; Perform a pass 1 FFT of length 640 doubles.
;; Memory examples are for a 640K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*16 + 2*4*clm*YMM_SCND4 + clm*YMM_SCD4 + 10*clm*YMM_SCD8 = 134*clm 64-byte cache lines
;;
;; IDEA: instead of (20 4 8) we should try (10 4 4 4) with either the first 4 variable or fixed
;; Sin/cos data needed: 4*4*clm*YMM_SCD4 + 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 5*clm*YMM_SCD4 = 111*clm 64-byte cache lines
;; Sin/cos data needed: 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 20*clm*YMM_SCD4 = 107*clm 64-byte cache lines

;; This pass processes 320*clm cache lines, or 80KB if clm=4, suggesting we should use clm=4:  80KB of scratch area, 80KB of input FFT data,
;; 80KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc640 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 640, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 640K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 39 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 72 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD4]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 20*4*clm			;; 10*4*clm or 20*4*clm iterations
	lea	rbx, [rdi+10*clm*YMM_SCD8+2*4*clm*16] ;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YSINGLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst, rdi, clm*YMM_SCD8 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	10, c9a, -10*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 10*4*clm			;; 10*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8	;; Test loop counter, next dest pointer, next sin/cos pointer
	yloop	10, c9b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*8]		;; Sin/cos ptr
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	10, c7b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K	...

;; Do 32 twenty_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 80 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 80
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 80

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 80 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 46*4*blkdst	;; We've already prefetched 46 blocks which will be 2 too few!
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst	;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 72 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 39 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rbx+10*clm*YMM_SCD8]	;; Premultiplier/sin/cos ptr
	lea	rdi, [rdx+2*4*clm*16]		;; Premultiplier/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 or 10 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD4]		;; Real data sin/cos ptr
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 72*clm cache lines
	yloop_set_alternate_prefetch_increment 134, (72+78)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YDOUBLE		;; Prefetch 78*clm cache lines
	yloop_set_alternate_prefetch_increment 134, (72+78)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rbx, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	end_timer 26

	yloop	20, b7a				;; 10 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*16 + clm*YMM_SCD4 + 10*clm*YMM_SCD8 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 72*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	10, b7b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*16-10*clm*YMM_SCD8 ;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD4]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 10*4*clm			;; 10 iters of 4*clm
pfing	bump	rcx, (134-72-78)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YDOUBLE		;; Prefetch 78 cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	yloop	10, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 640 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 640 doubles.
;; Memory examples are for a 640K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 20*clm*YMM_SCD4 = 107*clm 64-byte cache lines

;; This pass processes 320*clm cache lines, or 80KB if clm=4, suggesting we should use clm=4:  80KB of scratch area, 80KB of input FFT data,
;; 80KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

IFDEF LESS_MEMORY_BUT_SLOWER
-- warning: this code does not work (I never figured out the gwtables.c changes necessary to make it work)  I was able to get timings and 
-- the savings do not compensate for the addition of another macro level.  The unanswered question is would this end up being a winner when
-- we run 4 workers and become memory bandwidth limited, after all we are using less memory.

yr4dwpn_pass1sc640 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 640, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 640K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 79 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 19.75 macros each processing 32 data values

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 76 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 19 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 20*4*clm			;; 20*4*clm iterations
	lea	rbx, [rdi+20*clm*YMM_SCD4+4*clm*16] ;; Sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7b				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

	yloop_set_clm_prefetch YSINGLE		;; Prefetch 19 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, clm*YMM_SCD4, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer, next sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	10, c9a, -10*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	2, c9b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	10, c9b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 19 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	10, c7b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4 (actually 3.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K	...

;; Do 64 ten_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 40 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80 cache lines of data (+1/5 due to ineffective L1 prefetching) + 24+52 cache lines of s/c data.
;; A grand total of 16128 bytes -- should fit in a 32KB L1 cache.

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rdi, [rbp+16*YMM_SCD4]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 20*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 3*4			;; Do 20 rather than 32 iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	8, c5b, -5*2*clmblkdst8		;; 5 iterations!!  Restore source pointer
	loops_undo 8*4
	end_timer 18

	start_timer 20
	yloop_adjust 2*2*4			;; Do 16 rather than 32 iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_ten_reals_unfft_preload
c1b:	yr5_5cl_ten_reals_unfft rsi, 64, 2*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD4 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD4 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rdi, YMM_SCD4, rbp, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 16*YMM_SCD4		;; Sin/cos ptr
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos pointer
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos pointer
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	5, c5b, -5*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -16*YMM_SCD4		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_ten_reals_unfft_preload
c1b:	yr5_5cl_ten_reals_unfft rsi, 64, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 80
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 80

;; Do FFT levels 1,2,3,4 (actually 3.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 ten_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 40 data values

;; Do FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80 cache lines of data (+1/4 due to ineffective L1 prefetching) + 36+16 cache lines of s/c data.
;; A grand total of 16128 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, (51-3)*4*blkdst		;; We've already prefetched 51 blocks which will be 3 too many

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rdi, [rbp+16*YMM_SCD4]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 16 or 20 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_ten_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr5_5cl_ten_reals_fft rsi, 64, 2*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD4 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 3*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	8, b5b, -5*2*clmblkdst8+4*64	;; 5 iterations!!  Next source pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rdi, YMM_SCD4, rbp, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst, rdi, -4*clm*4*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_ten_reals_fft_preload
b1b:	yr5_5cl_ten_reals_fft rsi, 64, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; Test loop counter, next source ptr, next sin/cos ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4	;; Test loop counter, next source pointer, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	5, b5b, -5*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 76 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 19 macros each processing 32 data values

;; Do FFT levels 9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 79 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 19.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, clm*YMM_SCD2 + 20*clm*YMM_SCD4 ;; Timer 25 complex sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Timer 25 real sin/cos ptr
	lea	rbx, [rdx-20*clm*YMM_SCD4]	;; Timer 26 complex data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 20*4*clm			;; 40 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 76*clm cache lines
	yloop_set_alternate_prefetch_increment 107, (76+40)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YHALF		;; Prefetch 40*clm cache lines
	yloop_set_alternate_prefetch_increment 107, (76+40)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	10, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdx, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdx, clm*YMM_SCD2 + 20*clm*YMM_SCD4 ;; Real sin/cos ptr
	lea	rdi, [rdx+4*clm*16]		;; Complex data sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 76*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	10, b7b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-20*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 40*clm cache lines
pfing	bump	rcx, (107-76-40)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	yloop	2, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	10, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 640 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF


;; Perform a pass 1 negacyclic FFT of length 640 doubles.
;; Memory examples are for a 640K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD2 + 4*clm*16 + 4*clm*YMM_SCND2 + 4*clm*YMM_SCD4 = 61*clm 64-byte cache lines

;; This pass processes 320*clm cache lines, or 80KB if clm=4, suggesting we should use clm=4:  80KB of scratch area, 80KB of input FFT data,
;; 80KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc640ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 640, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 640K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 80 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 80 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD4+4*clm*16] ;; Load second premult/sin/cos pointer
	yloop_init 20*4*clm			;; 20*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	5, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -20*4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCND2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	20, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	20, c7b, -20*4*clmblkdst, rdi, 4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...

;; Do 64 five_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 40 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K	...

;; Do 80 four_complex_unfft operations
;;	distance between fft data elements is 80K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 16 or 20 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+20*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	8, c5b, -4*20*clmblkdst, rdi, 4*clm*YMM_SCD2 ;; 4 iterations!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -5*4*clmblkdst+clmblkdst, rbp, -5*4*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+20*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	20, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 80
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 80

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...

;; Do 80 four_complex_first_fft operations
;;	distance between fft data elements is 80K
;;	do 20 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 five_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 40 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 30+8*clm cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 44*4*blkdst		;; We've already prefetched 44 blocks

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 4*clm*16 + 4*clm*YMM_SCND2 + 4*clm*YMM_SCD4
	yloop_init 32*4*clm			;; 20 or 16 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -5*4*clmblkdst, rdi, -5*4*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, 4*clmblkdst, rbp, YMM_SCD2, 4*clm
	yloop	4*clm, b5b, -4*clm*64+20*clmblkdst, rbp, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	8, b5b, -4*20*clmblkdst+clmblkdst, rbp, 4*clm*YMM_SCD2 ;; 4 iterations!! next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-4*4*clm*YMM_SCD2-4*clm*YMM_SCND2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	20, b1b, -20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND2 + 4*clm*YMM_SCD4
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+20*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -4*clm*YMM_SCND2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 80 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 20 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 80 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-4*clm*YMM_SCD4]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 40*clm cache lines
	yloop_set_alternate_prefetch_increment 61, (40+40)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer. restore sin/cos ptrs
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	yloop_set_prefetch YHALF		;; Prefetch 40*clm cache lines
	yloop_set_alternate_prefetch_increment 61, (40+40)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	5, b7a				;; Test loop counter
	bump	rbx, clm*YMM_SCD4		;; Next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_prefetch YHALF
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	20, b7b, -20*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-4*clm*YMM_SCD4	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
pfing	bump	rcx, (61-40-40)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	20, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 640 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 768 doubles.
;; Memory examples are for a 768K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*16 + 2*4*clm*YMM_SCND4 + clm*YMM_SCD4 + 12*clm*YMM_SCD8 = 150*clm 64-byte cache lines

;; This pass processes 384*clm cache lines, or 96KB if clm=4, suggesting we should use clm=2:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

;; POSSIBLE BUGS - NOT TESTED (converted from working wpn4 code)
yr4dwpn_pass1sc768 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 768, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 768K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 47 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 88 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 22 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD4]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 24*4*clm			;; 12*4*clm or 24*4*clm iterations
	lea	rbx, [rdi+12*clm*YMM_SCD8+2*4*clm*16] ;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YDOUBLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 24 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst, rdi, clm*YMM_SCD8 ;; Test loop counter, restore scratch area pointer, next sin/cos ptr
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*8]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	12, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+2*4*clm*YMM_SCND4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YDOUBLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 24 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next dest pointer, next sin/cos pointer
	yloop	12, c9b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*8]		;; Weights ptr
	yloop_init 24*4*clm			;; 24*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	12, c7b, -12*clmblkdst8, rdi, 2*4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...

;; Do 32 twenty_four_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 96 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 96
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 96

;; Do FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_four_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 96 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 64*4*blkdst		;; We've already prefetched 64 blocks
	yloop_init 8*4*clm			;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD		;; Prefetch 32 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst		;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 72 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 47 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rbx+12*clm*YMM_SCD8]	;; Weights ptr
	lea	rdi, [rdx+2*4*clm*16]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 or 12 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD4]		;; Real data sin/cos ptr
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*16]		;; Weights ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 88*clm cache lines
	yloop_set_alternate_prefetch_increment 150, (88+94)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YDOUBLE		;; Prefetch 94*clm cache lines
	yloop_set_alternate_prefetch_increment 150, (88+94)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rbx, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	end_timer 26

	yloop	24, b7a				;; 12 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*16 + clm*YMM_SCD4 + 12*clm*YMM_SCD8 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*16]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 iterations of 4*clm
	yloop_set_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 88*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*16-4*clm*YMM_SCD8	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD4]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
pfing	bump	rcx, (150-88-94)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YDOUBLE		;; Prefetch 94*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	yloop	12, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 768 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM

IFDEF OLD_WAY
;; Perform a pass 1 FFT of length 768 doubles.
;; Memory examples are for a 768K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 8*4*clm*YMM_SCD2 + 2*4*clm*16 + 2*4*clm*YMM_SCND4 + clm*YMM_SCD4 + 4*clm*YMM_SCD8 = 150*clm 64-byte cache lines

;; This pass processes 384*clm cache lines, or 96KB if clm=4, suggesting we should use clm=2:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc768 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 768, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 768K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 47 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 88 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 22 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD4]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 24*4*clm			;; 12*4*clm or 24*4*clm iterations
	lea	rbx, [rdi+4*clm*YMM_SCD8+2*4*clm*16] ;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	3, c9a, 0, rdi, clm*YMM_SCD8	;; Test loop counter
	yloop	4, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+2*4*clm*YMM_SCND4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	3, c9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next sin/cos pointer
	yloop	4, c9b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*8]		;; Sin/cos ptr
	yloop_init 24*4*clm			;; 24*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	12, c7b, -12*clmblkdst8, rdi, 2*4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...

;; Do 32 six_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macro processing 24 data values
;; Do 96 three_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 24 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...

;; Do 96 eight_reals_unfft operations
;;	distance between fft data elements is 96K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+100% due to L1 prefetching next section) + 8*clm+12 cache lines of s/c data.
;; A grand total of 27392 bytes with clm=4 -- probably fitting in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 32*4*clm			;; 32 or 24 iters of 4*clm

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr3_3cl_csc_six_reals_unfft_preload
c4b:	yr3_3cl_csc_six_reals_unfft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm
	yloop	4*clm, c4b, -4*clm*64+3*clmblkdst8, rdi, -4*clm*YMM_SCD2 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm
	yloop	4*clm, c5b, -4*clm*64+3*clmblkdst8, rdi, -4*clm*YMM_SCD2 ;; Test loop counter
	yloop	4, c5b, -4*3*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbx, 8*YMM_SCD3 ;; Test loop counter
	yloop	4, c1b, -3*clmblkdst8+clmblkdst, rbx, -3*8*YMM_SCD3+YMM_SCD3 ;; 3 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c4a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF
	yr3_3cl_csc_six_reals_unfft_preload
c4b:	yr3_3cl_csc_six_reals_unfft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, c4b, -8*clmblkdst+3*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+3*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; 4 iterations, restore sine/cosine pointer
	yloop	4, c5b, -4*3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 24*4*clm			;; 24 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source ptr
	yloop	3, c1b				;; Test loop counter
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 96
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 96

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...

;; Do 96 eight_reals_fft operations
;;	distance between fft data elements is 96K
;;	do 24 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 six_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 24 data values
;; Do 96 four_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+100% due to L1 prefetching next section) + 12+8*clm cache lines of s/c data.
;; A grand total of 27392 bytes with clm=4 -- probably fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 64*4*blkdst		;; We've already prefetched 64 blocks

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rbx, 8*clm*16 + 8*clm*YMM_SCND4 + clm*YMM_SCD4 + 4*clm*YMM_SCD8 ;; Create second sin/cos ptr
	yloop_init 32*4*clm			;; 24 or 32 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD3 ;; 4*clm iters
	yloop	4, b1b, -3*clmblkdst8, rdi, -3*8*YMM_SCD3+YMM_SCD3 ;; Loop 3 times!! restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YQUARTER
	yr3_3cl_csc_six_reals_fft_preload
b4b:	yr3_3cl_csc_six_reals_fft rsi, 64, clmblkdst8, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b4b, -4*clm*64+3*clmblkdst8, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, clmblkdst8, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+3*clmblkdst8, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations
	yloop	4, b5b, -4*3*clmblkdst8+clmblkdst, rbx, 4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx-8*4*clm*YMM_SCD2]	;; Restore sin/cos ptr

ELSE

	start_timer 22
	yloop_init 24*4*clm			;; 24 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8	;; Loop, next source pointer
	yloop	3, b1b, -3*clmblkdst8		;; Loop, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 8*clm*16 + 8*clm*YMM_SCND4 + clm*YMM_SCD4 + 4*clm*YMM_SCD8 ;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YQUARTER
	yr3_3cl_csc_six_reals_fft_preload
b4b:	yr3_3cl_csc_six_reals_fft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, b4b, -8*clmblkdst+3*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, b5b, -8*clmblkdst+3*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 72 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 47 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rbx+4*clm*YMM_SCD8]	;; Premultiplier/sin/cos ptr
	lea	rdi, [rdx+2*4*clm*16]		;; Premultiplier/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 or 12 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD4]		;; Real data sin/cos ptr
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 88*clm cache lines
	yloop_set_alternate_prefetch_increment 150, (88+94)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YDOUBLE		;; Prefetch 94*clm cache lines
	yloop_set_alternate_prefetch_increment 150, (88+94)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	6, b7a, 0, rbx, clm*YMM_SCD8	;; 3 iterations!!!  Next premult/sine/cosine pointer
	yloop	4, b7a				;; 4 iterations

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*16 + clm*YMM_SCD4 + 4*clm*YMM_SCD8 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 88*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*16-4*clm*YMM_SCD8	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD4]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
pfing	bump	rcx, (150-88-94)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YDOUBLE		;; Prefetch 94 cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	3, b9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 768 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF

;; Perform a pass 1 FFT of length 768 doubles.
;; Memory examples are for a 768K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD2 + 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 = 91*clm 64-byte cache lines

IFDEF LOTS_LESS_MEM_BUT_SLOWER
--- using this requires changing clmblkdst padding in ymult.mac and gwnum.c
--- we think its slower because 3-complex is pretty inefficient, s.b. 16 clocks but is 27 clocks. (or 3-complex isn't efficient reading the variable s/c data)
--- it might also be due to inability to use clmblkdst8, or having double the group multipliers makes normalize slower
---- this might be faster:
;; 12 4 4 4 
;; Sin/cos data needed: 4*4*clm*YMM_SCD4 + 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 = 123*clm 64-byte cache lines

yr4dwpn_pass1sc768 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 768, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 768K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 95 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 23.75 macros each processing 32 data values

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 92 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 23 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 24*4*clm			;; 24*4*clm iterations
	lea	rbx, [rdi+8*clm*YMM_SCD4+4*clm*16] ;; Second sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	yloop	3, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	8, c9a, -24*4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCND4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 24*4*clm			;; 24*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	12, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	8, c9b, -8*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 24*4*clm			;; 24*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	24, c7b, -24*4*clmblkdst, rdi, 4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 16 six_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 24 data values
;; Do 112 three_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 28 macros each processing 24 data values

;; Do inverse FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...

;; Do 48 sixteen_reals_unfft operations
;;	distance between fft data elements is 48K
;;	do 12 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 96*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+21 cache lines of s/c data.
;; A grand total of 31040 bytes with clm=4 -- barely fitting in a 32KB L1 cache.
;;   IDEA:  Extract the clm from the inner loop (as we do in bigger FFTs)

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 32*4*clm			;; 32 or 12 iters of 4*clm

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr3_3cl_csc_six_reals_unfft_preload
c4b:	yr3_3cl_csc_six_reals_unfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+12*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+12*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; Test loop counter
	yloop	8, c5b, -8*12*clmblkdst, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 5*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 12*clmblkdst, 24*clmblkdst, 48*clmblkdst, rbx, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbx, 4*YMM_SCD7 ;; Test loop counter
	yloop	8, c1b, -3*4*clmblkdst+clmblkdst, rbx, -3*4*YMM_SCD7+YMM_SCD7 ;; 3 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF
	yr3_3cl_csc_six_reals_unfft_preload
c4b:	yr3_3cl_csc_six_reals_unfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; 4 iterations, restore sine/cosine pointer
	yloop	8, c5b, -8*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 12*4*clm			;; 12 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 12*clmblkdst, 24*clmblkdst, 48*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iterations
	yloop	12, c1b				;; Test loop counter
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 96
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 96

;; Do FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 48 sixteen_reals_fft operations
;;	distance between fft data elements is 48K
;;	do 12 iterations each processing 64 data values

;; Do FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 six_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 24 data values
;; Do 112 three_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 28 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 96*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 21+8*clm cache lines of s/c data.
;; A grand total of 31040 bytes with clm=4 -- barely fitting in a 32KB L1 cache.
;;   IDEA:  Extract the clm from the inner loop (as we do in bigger FFTs)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 52*4*blkdst		;; We've already prefetched 52 blocks

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rbx, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 ;; Create second sin/cos ptr
	yloop_init 32*4*clm			;; 12 or 32 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 5*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 12*clmblkdst, 24*clmblkdst, 48*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD7 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -3*4*clmblkdst, rdi, -3*4*YMM_SCD7+YMM_SCD7 ;; Loop 3 times!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YSINGLE
	yr3_3cl_csc_six_reals_fft_preload
b4b:	yr3_3cl_csc_six_reals_fft rsi, 64, 4*clmblkdst, rbx, YMM_SCD2, 4*clm
	yloop	4*clm, b4b, -4*clm*64+12*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rbx, YMM_SCD2, 4*clm
	yloop	4*clm, b5b, -4*clm*64+12*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations
	yloop	8, b5b, -8*12*clmblkdst+clmblkdst, rbx, 4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx-4*4*clm*YMM_SCD2]	;; Restore sin/cos ptr

ELSE

	start_timer 22
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 12*clmblkdst, 24*clmblkdst, 48*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	12, b1b, -12*clmblkdst		;; Loop, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 ;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr3_3cl_csc_six_reals_fft_preload
b4b:	yr3_3cl_csc_six_reals_fft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b4b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	8, b5b, -8*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 92 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 23 macros each processing 32 data values

;; Do FFT levels 9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 95 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 23.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, -4*clm*YMM_SCND4		;; Premultiplier/sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-8*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YHALF		;; Prefetch 46*clm cache lines
	yloop_set_alternate_prefetch_increment 91, (46+47)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YHALF		;; Prefetch 47*clm cache lines
	yloop_set_alternate_prefetch_increment 91, (46+47)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	3, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	8, b7a				;; Test loop counter

ELSE

	start_timer 25
	bump	rdi, -4*clm*YMM_SCND4		;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 46*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	24, b7b, -24*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-8*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 24*4*clm			;; 24 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer

	loops_reset
pfing	bump	rcx, (91-46-47)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF		;; Prefetch 47*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer
	yloop	12, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	8, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 768 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF


;; Perform a pass 1 negacyclic FFT of length 768 doubles.
;; Memory examples are for a 768K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 8*4*clm*YMM_SCD1 + 2*4*clm*16 + 2*4*clm*YMM_SCND2 + 4*clm*YMM_SCD8 = 90*clm 64-byte cache lines

;; This pass processes 384*clm cache lines, or 96KB if clm=4, suggesting we should use clm=2:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This ought to fit in 256KB L2 cache.

yr4dwpn_pass1sc768ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 768, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 768K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 48 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines of input FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- marginally fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD8+2*4*clm*16] ;; Load second premult/sin/cos pointer
	yloop_init 24*4*clm			;; 12*4*clm or 24*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*8]		;; Sin/cos ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	3, c9a, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+2*4*clm*YMM_SCND2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	3, c9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*8]		;; Sin/cos ptr
	yloop_init 24*4*clm			;; 24*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	12, c7b, -12*clmblkdst8, rdi, 2*4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...

;; Do 128 three_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 24 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...

;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 96K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+100% prefetching next scratch area section) + 4*clm+24 cache lines of s/c data.
;; A grand total of 27136 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 32 or 24 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, clmblkdst8, rdi, YMM_SCD1, 4*clm
	yloop	4*clm, c5b, -4*clm*64+3*clmblkdst8, rdi, -4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, c5b, -4*3*clmblkdst8, rdi, 4*clm*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -3*clmblkdst8+clmblkdst, rbp, -3*8*YMM_SCD6+YMM_SCD6 ;; Loop 3 times!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, clmblkdst8, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+3*clmblkdst8, rdi, -8*4*clm*YMM_SCD1 ;; 8 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 24*4*clm			;; 24 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8	;; Test loop counter
	yloop	3, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 96
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 96

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...

;; Do 96 four_complex_first_fft operations
;;	distance between fft data elements is 96K
;;	do 24 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 three_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+100% prefetching next scratch area section) + 24+4*clm cache lines of s/c data.
;; A grand total of 27136 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 64*4*blkdst		;; We've already prefetched 64 blocks

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 2*4*clm*16 + 2*4*clm*YMM_SCND2 + 4*clm*YMM_SCD8
	yloop_init 32*4*clm			;; 24 or 32 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -3*clmblkdst8, rdi, -3*8*YMM_SCD6+YMM_SCD6 ;; 3 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, clmblkdst8, rbp, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+3*clmblkdst8, rbp, -4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, b5b, -4*3*clmblkdst8+clmblkdst, rbp, 4*clm*YMM_SCD1 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-8*4*clm*YMM_SCD1-2*4*clm*YMM_SCND2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 24*4*clm			;; 24 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	3, b1b, -3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 2*4*clm*16 + 2*4*clm*YMM_SCND2 + 4*clm*YMM_SCD8
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, clmblkdst8, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, b5b, -8*clmblkdst+3*clmblkdst8, rdi, -8*4*clm*YMM_SCD1 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -2*4*clm*YMM_SCND2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 96 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 24 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 48 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-4*clm*YMM_SCD8]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 or 12 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 90, (48+48)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YSINGLE		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 90, (48+48)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	6, b7a, 0, rbx, clm*YMM_SCD8	;; 3 iterations!!!  Next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 iters of 4*clm
	yloop_set_prefetch YHALF		;; Prefetch 48*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*16-4*clm*YMM_SCD8	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (90-48-48)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YSINGLE		;; Prefetch 48*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	3, b9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 768 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 896 doubles.
;; Memory examples are for a 896K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*16 + 2*4*clm*YMM_SCND4 + clm*YMM_SCD4 + 14*clm*YMM_SCD8 = 166*clm 64-byte cache lines
;; 
;; or would 14 4 4 4 be better than the implemented 28 4 8:
;; Sin/cos data needed: 4*4*clm*YMM_SCD4 + 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 7*clm*YMM_SCD4 = 119*clm 64-byte cache lines

;; This pass processes 448*clm cache lines, or 112KB if clm=4, suggesting we should use clm=2:  56KB of scratch area, 56KB of input FFT data,
;; 56KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc896 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9b, c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 896, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 896K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 55 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 104 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 26 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD4]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (112*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 28*4*clm			;; 14*4*clm or 28*4*clm iterations
	lea	rbx, [rdi+14*clm*YMM_SCD8+2*4*clm*16] ;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YDOUBLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 28 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst, rdi, clm*YMM_SCD8 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 26 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	14, c9a, -14*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 14*4*clm			;; 14*4*clm iterations
	yloop_set_clm_prefetch YDOUBLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 28 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8	;; Test loop counter, next dest pointer, next sin/cos pointer
	yloop	14, c9b, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*8]		;; Sin/cos ptr
	yloop_init 28*4*clm			;; 28*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 26 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	14, c7b, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	448K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	444K	...

;; Do 32 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 112 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 112
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 112

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	448K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	444K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_eight_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 112 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, (86-6)*4*blkdst	;; We've already prefetched 86 blocks which will be 6 too many
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 104 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 26 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 55 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (112*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rbx+14*clm*YMM_SCD8]	;; Premultiplier/sin/cos ptr
	lea	rdi, [rdx+2*4*clm*16]		;; Premultiplier/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 28*4*clm			;; 28 or 14 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YSINGLE		;; Prefetch 8*clm cache lines
	yloop_set_alternate_prefetch_increment 165, (8+104+55)
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD4]		;; Real data sin/cos ptr
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 104*clm cache lines
	yloop_set_alternate_prefetch_increment 165, (8+104+55)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 55*clm cache lines
	yloop_set_alternate_prefetch_increment 165, (8+104+55)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rbx, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	end_timer 26

	yloop	28, b7a				;; 14 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*16 + clm*YMM_SCD4 + 14*clm*YMM_SCD8 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 28*4*clm			;; 28 iterations of 4*clm
	yloop_set_prefetch YSINGLE		;; Prefetch 8*clm cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 104*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	14, b7b, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*16-14*clm*YMM_SCD8 ;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD4]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 14*4*clm			;; 14 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 55*clm cache lines
pfing	bump	rcx, (166-8-104-55)*clm*64	;; Finish prefetching the sin/cos/premult data
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	yloop	14, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 896 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1024 doubles.
;; Memory examples are for a 1024K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*16 + 2*4*clm*YMM_SCND4 + clm*YMM_SCD4 + 16*clm*YMM_SCD8 = 182*clm 64-byte cache lines

;; This pass processes 512*clm cache lines, or 128KB if clm=4, suggesting we should use clm=2:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc1024 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1024, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1024K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 63 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 120 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 30 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD4]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 16*4*clm or 32*4*clm iterations
	lea	rbx, [rdi+16*clm*YMM_SCD8+2*4*clm*16] ;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst, rdi, clm*YMM_SCD8 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	16, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8	;; Test loop counter, next dest pointer, next sin/cos pointer
	yloop	16, c9b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*8]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	16, c7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macro processing 32 data values
;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...

;; Do 128 eight_reals_unfft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+12 cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rdi+32*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+4*clmblkdst8 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+4*clmblkdst8 ;; Test loop counter
	yloop	4, c5b, -4*4*clmblkdst8, rbx, YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 18
	loops_undo 4*4*clm

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD3 ;; Test loop counter
	yloop	4, c1b, -4*clmblkdst8+clmblkdst, rdi, -4*8*YMM_SCD3+YMM_SCD3 ;; 4 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 32*YMM_SCD3		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations

	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, c4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; 8 iterations, restore sine/cosine pointer
	yloop	4, c5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -32*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 128
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 128

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 eight_reals_fft operations
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values
;; Do 96 four_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 12+4 cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 80*4*blkdst		;; We've already prefetched 80 blocks

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+32*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD3 ;; 4*clm iters, next source ptr, next sin/cos ptr
	yloop	4, b1b, -4*clmblkdst8, rdi, -4*8*YMM_SCD3+YMM_SCD3 ;; 4 iterations, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b4b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*4*clmblkdst8+clmblkdst, rbx, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3	;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, b1b, -4*clmblkdst8		;; 4 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 120 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 30 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 63 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rbx+16*clm*YMM_SCD8]	;; Premultiplier/sin/cos ptr
	lea	rdi, [rdx+2*4*clm*16]		;; Premultiplier/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 or 16 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD4]		;; Real data sin/cos ptr
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 120*clm cache lines
	yloop_set_alternate_prefetch_increment 182, (120+63)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
	yloop_set_alternate_prefetch_increment 182, (120+63)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rbx, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	end_timer 26

	yloop	32, b7a				;; 16 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*16 + clm*YMM_SCD4 + 16*clm*YMM_SCD8 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 120*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*16-16*clm*YMM_SCD8 ;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD4]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (182-120-64)*clm*64	;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YSINGLE		;; Prefetch 1*clm cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	yloop	16, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1024 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1024 doubles.
;; Memory examples are for a 1024K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD4 + 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 = 123*clm 64-byte cache lines

;; This pass processes 512*clm cache lines, or 128KB if clm=4, suggesting we should use clm=2:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

IFDEF SLOWER_EVEN_THOUGH_IT_USES_LESS_MEMORY
yr4dwpn_pass1sc1024 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1024, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1024K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 127 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 31.75 macros each processing 32 data values

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 124 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 31 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 32*4*clm iterations
	lea	rbx, [rdi+8*clm*YMM_SCD4+4*clm*16] ;; Sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	8, c9a, -8*2*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCND4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	8, c9b, -8*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	16, c7b, -16*clmblkdst8, rdi, 4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 112 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 28 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...

;; Do 64 sixteen_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 128*clm cache lines of data (+1/(4*clm) due to ineffective L1 prefetching) + 16*clm+28 cache lines of s/c data.
;; A grand total of 40704 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.
;;   IDEA:  Extract the clm from the inner loop (as we do in bigger FFTs)

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 32*4*clm			;; 32 or 16 iters of 4*clm

c4a:	start_timer 18
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+2*clmblkdst8, rdi, -4*clm*YMM_SCD4 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+2*clmblkdst8, rdi, -4*clm*YMM_SCD4 ;; Test loop counter
	yloop	8, c5b, -8*2*clmblkdst8, rdi, 4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 2*2*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, 8*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbx, 4*YMM_SCD7 ;; Test loop counter
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, c1b, -2*clmblkdst8+clmblkdst, rbx, -4*4*YMM_SCD7+YMM_SCD7 ;; 2 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	8, c5b, -8*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8	;; Test loop counter
	yloop	2, c1b				;; Test loop counter
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 128
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 128

;; Do FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 64 data values

;; Do FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 112 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 28 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 128*clm cache lines of data (+1/(4*clm) due to ineffective L1 prefetching) + 28+16*clm cache lines of s/c data.
;; A grand total of 40704 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.
;;   IDEA:  Extract the clm from the inner loop (as we do in bigger FFTs)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 80*4*blkdst		;; We've already prefetched 80 blocks

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rbx, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 ;; Create second sin/cos ptr
	yloop_init 32*4*clm			;; 16 or 32 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 2*2*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD7 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, b1b, -2*clmblkdst8, rdi, -2*2*4*YMM_SCD7+YMM_SCD7 ;; Loop 2 times!! restore source pointer, next sin/cos ptr
	loops_undo 4*2*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, YMM_SCD4, 4*clm
	yloop	4*clm, b4b, -4*clm*64+2*clmblkdst8, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, YMM_SCD4, 4*clm
	yloop	4*clm, b5b, -4*clm*64+2*clmblkdst8, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations
	yloop	8, b5b, -8*2*clmblkdst8+clmblkdst, rbx, 4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx-4*4*clm*YMM_SCD4]	;; Restore sin/cos ptr

ELSE

	start_timer 22
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8	;; Loop, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; Loop, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 ;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	8, b5b, -8*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 124 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 31 macros each processing 32 data values

;; Do FFT levels 9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 127 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 31.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, -4*clm*YMM_SCND4		;; Premultiplier/sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-8*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 32*4*clm			;; 32 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YHALF		;; Prefetch 62*clm cache lines
	yloop_set_alternate_prefetch_increment 123, (62+63)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YHALF		;; Prefetch 63*clm cache lines
	yloop_set_alternate_prefetch_increment 123, (62+63)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	8, b7a				;; Test loop counter

ELSE

	start_timer 25
	bump	rdi, -4*clm*YMM_SCND4		;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 62*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	16, b7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-8*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer

	loops_reset
pfing	bump	rcx, (123-62-63)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF		;; Prefetch 63*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	8, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1024 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF


;; Perform a pass 1 negacyclic FFT of length 1024 doubles.
;; Memory examples are for a 1024K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 8*4*clm*YMM_SCD2 + 2*4*clm*16 + 2*4*clm*YMM_SCND2 + 4*clm*YMM_SCD8 = 122*clm 64-byte cache lines

;; This pass processes 512*clm cache lines, or 128KB if clm=4, suggesting we should use clm=2:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc1024ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 1024, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1024K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 64 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines of input FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- marginally fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD8+2*4*clm*16] ;; Load second premult/sin/cos pointer
	yloop_init 32*4*clm			;; 16*4*clm or 32*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*8]		;; Sin/cos ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	4, c9a, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+2*4*clm*YMM_SCND2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	4, c9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*8]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	16, c7b, -16*clmblkdst8, rdi, 2*4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 32*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+4*clmblkdst8, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, c5b, -4*4*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -4*clmblkdst8+clmblkdst, rbp, -4*8*YMM_SCD6+YMM_SCD6 ;; 4 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; 8 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 128
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 128

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 four_complex_first_fft operations
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 four_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 80*4*blkdst		;; We've already prefetched 80 blocks

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 8*clm*16 + 8*clm*YMM_SCND2 + 4*clm*YMM_SCD8
	yloop_init 32*4*clm			;; 32 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst8, rdi, -4*8*YMM_SCD6+YMM_SCD6 ;; 4 iterations, restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbp, YMM_SCD2, 4*clm
	yloop	4*clm, b5b, -4*clm*64+4*clmblkdst8, rbp, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, b5b, -4*4*clmblkdst8+clmblkdst, rbp, 4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-8*4*clm*YMM_SCD2-8*clm*YMM_SCND2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, b1b, -4*clmblkdst8		;; 4 iterations
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 8*clm*16 + 8*clm*YMM_SCND2 + 4*clm*YMM_SCD8
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, b5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -8*clm*YMM_SCND2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 128 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 64 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-4*clm*YMM_SCD8]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 or 16 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 122, (64+64)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YSINGLE		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 122, (64+64)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	8, b7a, 0, rbx, clm*YMM_SCD8	;; 4 iterations!!!  Next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_prefetch YHALF		;; Prefetch 64*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*16-4*clm*YMM_SCD8	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (122-64-64)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YSINGLE		;; Prefetch 64*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1024 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1280 doubles.
;; Memory examples are for a 1280K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD4 + 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 10*clm*YMM_SCD4 = 131*clm 64-byte cache lines

;; This pass processes 640*clm cache lines, or 160KB if clm=4, suggesting we should use clm=1:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1280 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1280, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1280K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 159 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 39.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 156 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 39 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 40*4*clm			;; 40*4*clm iterations
	lea	rbx, [rdi+10*clm*YMM_SCD4+4*clm*16] ;; Sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7b				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	10, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCND4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	10, c9b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	20, c7b, -20*clmblkdst8, rdi, 4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 144 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 36 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K	...

;; Do 64 twenty_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 80 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 160 cache lines of data (+1/10 due to ineffective L1 prefetching) + 24+52 cache lines of s/c data.
;; A grand total of 16128 bytes -- should fit in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 64*4*clm			;; 40*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 6*4			;; Do 40 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -10*2*clmblkdst8, rdi, 4*YMM_SCD4 ;; 10 iterations!!  Restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 12*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD9 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD9 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD9 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	10, c5b, -10*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 160
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 160

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 80 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 144 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 36 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 160 cache lines of data (+1/4 due to ineffective L1 prefetching) + 36+16 cache lines of s/c data.
;; A grand total of 16128 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 92*4*blkdst		;; We've already prefetched 92 blocks

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 10*clm*YMM_SCD4 ;; Sin/cos ptr
	yloop_init 64*4*clm			;; 16 or 40 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr5_10cl_20_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD9 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD9 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 6*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4
	yloop	4, b4b, -4*64+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -10*2*clmblkdst8+4*64, rdi, 4*YMM_SCD4 ;; 10 iterations!!  Next source pointer, next sin/cos pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD9 ;; Test loop counter, next source pointer, next sin/cos pointer
	yloop	4, b1a, -4*clmblkdst, rdi, -4*clm*4*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 10*clm*YMM_SCD4 ;; Sin/cos ptr
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; Test loop counter, next source ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	10, b5b, -10*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 156 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 39 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 159 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 39.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCND4		;; Premultiplier/sin/cos ptr

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-10*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 40*4*clm			;; 40 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YHALF		;; Prefetch 78*clm cache lines
	yloop_set_alternate_prefetch_increment 131, (78+80)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YHALF		;; Prefetch 80*clm cache lines
	yloop_set_alternate_prefetch_increment 131, (78+80)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	10, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 78*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	20, b7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-10*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 40*4*clm			;; 40 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 80*clm cache lines
pfing	bump	rcx, (131-78-80)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	10, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1280 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 1280 doubles.
;; Memory examples are for a 1280K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 8*4*clm*YMM_SCD2 + 2*4*clm*16 + 2*4*clm*YMM_SCND2 + 4*clm*YMM_SCD8 = 122*clm 64-byte cache lines

;; This pass processes 640*clm cache lines, or 160KB if clm=4, suggesting we should use clm=1:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1280ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 1280, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1280K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 80 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 160 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD8+2*4*clm*16] ;; Load second premult/sin/cos pointer
	yloop_init 40*4*clm			;; 20*4*clm or 40*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*8]		;; Sin/cos ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rbx, YMM_SCND2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCND2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	5, c9a, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+2*4*clm*YMM_SCND2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	5, c9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*8]		;; Sin/cos ptr
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	20, c7b, -20*clmblkdst8, rdi, 2*4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...

;; Do 128 five_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 40 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K	...

;; Do 160 four_complex_unfft operations
;;	distance between fft data elements is 160K
;;	do 40 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 32 or 40 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+5*clmblkdst8, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	8, c5b, -4*5*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; 4 iterations!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -5*clmblkdst8+clmblkdst, rbp, -5*8*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+5*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	5, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 160
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 160

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...

;; Do 160 four_complex_first_fft operations
;;	distance between fft data elements is 160K
;;	do 40 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 five_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 40 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 88*4*blkdst		;; We've already prefetched 88 blocks

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 2*4*clm*16 + 2*4*clm*YMM_SCND2 + 4*clm*YMM_SCD8
	yloop_init 64*4*clm			;; 40 or 32 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch a short distance ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters
	yloop	8, b1b, -5*clmblkdst8, rdi, -5*8*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, clmblkdst8, rbp, YMM_SCD2, 4*clm
	yloop	4*clm, b5b, -4*clm*64+5*clmblkdst8, rbp, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	8, b5b, -4*5*clmblkdst8+clmblkdst, rbp, 4*clm*YMM_SCD2 ;; 4 iterations!! next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-8*4*clm*YMM_SCD2-2*4*clm*YMM_SCND2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 40*4*clm			;; 40 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	5, b1b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 2*4*clm*16 + 2*4*clm*YMM_SCND2 + 4*clm*YMM_SCD8
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, b5b, -8*clmblkdst+5*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -2*4*clm*YMM_SCND2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 160 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 80 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-4*clm*YMM_SCD8]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 or 20 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 80*clm cache lines
	yloop_set_alternate_prefetch_increment 122, (80+80)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YSINGLE		;; Prefetch 80*clm cache lines
	yloop_set_alternate_prefetch_increment 122, (80+80)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	10, b7a, 0, rbx, clm*YMM_SCD8	;; 5 iterations!!!  Next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-2*4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 iters of 4*clm
	yloop_set_prefetch YHALF		;; Prefetch 80*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*8, rdi, -2*4*clm*YMM_SCND2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	20, b7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*16-4*clm*YMM_SCD8	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
pfing	bump	rcx, (122-80-80)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YSINGLE		;; Prefetch 80*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1280 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1536 doubles.
;; Memory examples are for a 1536K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD2 + 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 = 123*clm 64-byte cache lines
;; 
;; or instead of 8 4 3 4 4, we could do 24 4 4 4:
;; Sin/cos data needed: 4*4*clm*YMM_SCD4 + 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 12*clm*YMM_SCD4 = 139*clm 64-byte cache lines
;;
;; or 16 6 4 4:
;; Sin/cos data needed: 4*4*clm*YMM_SCD3 + 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 = 107*clm 64-byte cache lines

;; This pass processes 768*clm cache lines, or 192KB if clm=4, suggesting we should use clm=1:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

IFDEF OLD_WAY
yr4dwpn_pass1sc1536 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3a, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c2b, c3a, c3b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1536, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1536K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 191 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 47.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 188 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 47 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 48*4*clm			;; 48*4*clm iterations
	lea	rbx, [rdi+16*clm*YMM_SCD4+4*clm*16] ;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 47 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	yloop	3, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	16, c9a, -48*4*clmblkdst	;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCND4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	12, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	16, c9b, -192*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 47 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	48, c7b, -48*4*clmblkdst, rdi, 4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 16 six_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 24 data values
;; Do 240 three_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 60 macros each processing 24 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...

;; Do 48 eight_reals_unfft operations
;;	distance between fft data elements is 48K
;;	do 12 macro processing 32 data values
;; Do 144 four_complex_unfft operations
;;	distance between fft data elements is 48K
;;	do 36 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...

;; Do 192 eight_reals_unfft operations
;;	distance between fft data elements is 192K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/16 due to ineffective L1 prefetching) + 8+12+36 cache lines of s/c data.
;; A grand total of 16640 bytes -- easily fitting in a 32KB L1 cache.

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rbp+48*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm or 48*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr3_3cl_csc_six_reals_unfft_preload
c4b:	yr3_3cl_csc_six_reals_unfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4, L1PREFETCH_ALL, 12*clmblkdst ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4, L1PREFETCH_ALL, 12*clmblkdst ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*12*clmblkdst, rdi, 4*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 19
	yloop_adjust 4				;; Fewer than normal iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c2b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, c2b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	4, c2b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD4 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer

	loops_reset
c3a:	yloop_adjust 4				;; Fewer than normal iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	4, c3b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD4 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer
	yloop	4, c3a, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_adjust 4*4			;; Fewer than normal iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 24 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD3 ;; Test loop counter, next sin/cos ptr
	yloop	16, c1b, -12*4*clmblkdst+4*64, rbp, -12*4*YMM_SCD3 ;; 12 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbx, YMM_SCD4, rbp, YMM_SCD3 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr3_3cl_csc_six_reals_unfft_preload
c4b:	yr3_3cl_csc_six_reals_unfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	16, c5b, -16*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 48*YMM_SCD3		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c2b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c2b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos pointer
	yloop	12, c2b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sine/cosine pointer
	yloop	12, c3b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD4 ;; Test loop counter, restore sine/cosine pointer
	yloop	4, c3b, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -48*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_clm_prefetch YHALF		;; Prefetch 24 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	48, c1b				;; 48 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 192
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 192

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...

;; Do 192 eight_reals_fft operations
;;	distance between fft data elements is 192K
;;	do 48 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 48 eight_reals_fft operations
;;	distance between fft data elements is 48K
;;	do 12 macros each processing 32 data values
;; Do 144 four_complex_fft operations
;;	distance between fft data elements is 48K
;;	do 36 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 six_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 24 data values
;; Do 240 three_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 60 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/12 due to ineffective L1 prefetching) + 8+12+36 cache lines of s/c data.
;; A grand total of 16896 bytes -- easily fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, (107-11)*4*blkdst		;; We've already prefetched 107 blocks which will be 11 too many

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rbx, [rbp+48*YMM_SCD3]		;; Sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Sin/cos ptr
	yloop_init 64*4*clm			;; 48 or 64 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 4*4			;; Fewer iterations this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 48*clmblkdst, 96*clmblkdst, rbp, 0, 4, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD3 ;; Test loop counter, next sin/cos ptr
	yloop	16, b1b, -12*4*clmblkdst, rbp, -12*4*YMM_SCD3 ;; 12 iterations!!  Restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
	yloop_adjust 4				;; Fewer iterations this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b2b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, b2b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	4, b2b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD4 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer

	loops_reset
b3a:	yloop_adjust 4				;; Fewer iterations this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	4, b3b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD4 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer
	yloop	4, b3a, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YNONE
	yr3_3cl_csc_six_reals_fft_preload
b4b:	yr3_3cl_csc_six_reals_fft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4
	yloop	4, b4b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 60 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4
	yloop	4, b5b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*12*clmblkdst+4*64, rdi, 4*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD4, rbp, YMM_SCD3 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst, rdi, -4*clm*4*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 48*clmblkdst, 96*clmblkdst, rdi, 0, 4, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters
	yloop	48, b1b, -48*clmblkdst		;; 48 iterations, restore source pointer
	end_timer 22

	start_timer 23
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b2b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b2b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	12, b2b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	12, b3b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	4, b3b, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND4 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr3_3cl_csc_six_reals_fft_preload
b4b:	yr3_3cl_csc_six_reals_fft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; Test loop counter, next source ptr
	yloop	4, b4b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 60 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	16, b5b, -16*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 188 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 47 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 191 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 47.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCND4		;; Premultiplier/sin/cos ptr

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-16*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YHALF		;; Prefetch 94*clm cache lines
	yloop_set_alternate_prefetch_increment 123, (94+48)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 123, (94+48)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	3, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 94*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	48, b7b, -48*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-16*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
pfing	bump	rcx, (123-94-48)*clm*64	;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	12, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1536 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF


;; Perform a pass 1 FFT of length 1536 doubles.
;; Memory examples are for a 1536K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*16 + 4*4*clm*YMM_SCND4 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 12*clm*YMM_SCD4 = 166*clm 64-byte cache lines

;; This pass processes 768*clm cache lines, or 192KB if clm=4, suggesting we should use clm=1:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1536 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1536, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1536K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 191 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 47.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 188 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 47 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 48*4*clm			;; 48*4*clm iterations
	lea	rbx, [rdi+12*clm*YMM_SCD4]	;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7b				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	12, c9a, -24*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	12, c9b, -24*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	24, c7b, -24*clmblkdst8, rdi, 4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 176 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 44 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...

;; Do 64 twenty_four_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 96 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/12 due to ineffective L1 prefetching) + 24+44 cache lines of s/c data.
;; A grand total of 17664 bytes -- should fit in a 32KB L1 cache.

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*8]		;; Sin/cos ptr
	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 64*4*clm			;; 48*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 4*4			;; Do 48 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -12*2*clmblkdst8, rdx, 4*8, rdi, 4*YMM_SCND4 ;; 12 iterations!!  Restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 6*2*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD11 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD11 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD11 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*8]		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; 4 iterations, restore sin/cos pointer
	yloop	12, c5b, -12*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 192
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 192

;; Do FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_four_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 96 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 176 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 44 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/4 due to ineffective L1 prefetching) + 44+24 cache lines of s/c data.
;; A grand total of 19712 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 128*4*blkdst		;; We've already prefetched 128 blocks

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*16 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 12*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 64*4*clm			;; 16 or 48 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr6_12cl_24_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD11 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD11 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 4*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4
	yloop	4, b4b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -12*2*clmblkdst8+4*64, rdx, 4*8, rdi, 4*YMM_SCND4 ;; 12 iterations!!  Next source pointer, next sin/cos pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD11 ;; Test loop counter, next source pointer, next sin/cos pointer
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*16-4*clm*4*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*16 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 12*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; Test loop counter, next source ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b5b, -12*2*clmblkdst8, rdi, -4*4*clm*16 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 188 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 47 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 191 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 47.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD4		;; Premultiplier/sin/cos ptr

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-12*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 94*clm cache lines
	yloop_set_alternate_prefetch_increment 166, (94+96)
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YHALF		;; Prefetch 96*clm cache lines
	yloop_set_alternate_prefetch_increment 166, (94+96)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	12, b7a				;; Test loop counter

ELSE

	start_timer 25
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 94*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	24, b7b, -24*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -12*clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 96*clm cache lines
pfing	bump	rcx, (166-94-96)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	12, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1536 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 1536 doubles.
;; Memory examples are for a 1536K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD1 + 4*clm*16 + 4*clm*YMM_SCND2 + 16*clm*YMM_SCD4 = 93*clm 64-byte cache lines

;; This pass processes 768*clm cache lines, or 192KB if clm=4, suggesting we should use clm=1:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1536ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b3a, b3b, b5b, b7a, b7b, b9b, c0b, c1b, c3a, c3b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 1536, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1536K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 192 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+16*clm*YMM_SCD4+4*clm*16] ;; Load second premult/sin/cos pointer
	yloop_init 48*4*clm			;; 48*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*8]		;; Sin/cos ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rbx, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCND2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	3, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	16, c9a, -48*4*clmblkdst	;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCND2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	12, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	16, c9b, -192*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*8]		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	48, c7b, -48*4*clmblkdst, rdi, 4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 256 three_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 24 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 48K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 192K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/16 due to ineffective L1 prefetching) + 4+6+72 cache lines of s/c data.
;; A grand total of 18304 bytes -- easily fitting in a 32KB L1 cache.

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 64*4*clm or 48*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+48*YMM_SCD6]		;; Second sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4, L1PREFETCH_ALL, 12*clmblkdst ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD1 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*12*clmblkdst, rdi, 4*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 16*4
	end_timer 18

	start_timer 19
c3a:	yloop_adjust 4				;; Fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	4, c3b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD2 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer
	yloop	4, c3a, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_adjust 4*4			;; Fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4 iterations, next sin/cos ptr
	yloop	16, c1b, -12*4*clmblkdst+4*64, rbp, -12*4*YMM_SCD6 ;; 12 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c5a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos pointer
	yloop	16, c5b, -16*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	bump	rdi, 48*YMM_SCD6		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos data
	yloop	12, c3b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD2 ;; 2 iterations, restore sin/cos pointer
	yloop	4, c3b, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -48*YMM_SCD6		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	48, c1b				;; 48 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 192
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 192

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...

;; Do 192 four_complex_first_fft operations
;;	distance between fft data elements is 192K
;;	do 48 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 48K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	48K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 three_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/12 due to ineffective L1 prefetching) + 4+6+72 cache lines of s/c data.
;; A grand total of 18560 bytes -- easily fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 144*4*blkdst		;; We've already prefetched 144 blocks

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+48*YMM_SCD6]		;; Second sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND2 + 16*clm*YMM_SCD4
	yloop_init 64*4*clm			;; 48 or 64 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 4*4			;; Fewer iterations this loop
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rbp, 0, 4, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; Test loop counter, next sin/cos ptr
	yloop	16, b1b, -12*4*clmblkdst, rbp, -12*4*YMM_SCD6 ;; 12 iterations!!  Restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
b3a:	yloop_adjust 4				;; Fewer iterations this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	4, b3b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD2 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer
	yloop	4, b3a, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4
	yloop	4, b5b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD1 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*12*clmblkdst+4*64, rdi, 4*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, b1a, -4*clmblkdst, rdi, -4*clm*4*YMM_SCD1 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	48, b1b, -48*clmblkdst		;; 48 iterations
	end_timer 22

	start_timer 23
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos pointer
	yloop	12, b3b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b3b, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*16 + 4*clm*YMM_SCND2 + 16*clm*YMM_SCD4
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	16, b5b, -16*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCND2		;; First sin/cos ptr

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
	lea	rbx, [rdx-16*clm*YMM_SCD4]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 93, (48+48)
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 93, (48+48)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	3, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*16]		;; Premultiplier/sin/cos ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yr4_b4cl_wpn_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*8, rdi, -4*clm*YMM_SCND2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	48, b7b, -48*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*16-16*clm*YMM_SCD4	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm
pfing	bump	rcx, (93-48-48)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	12, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1536 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1792 doubles.
;; Memory examples are for a 1792K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*16 + 4*4*clm*YMM_SCND4 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 14*clm*YMM_SCD4 = 174*clm 64-byte cache lines

;; This pass processes 896*clm cache lines, or 224KB if clm=4, suggesting we should use clm=1:  56KB of scratch area, 56KB of input FFT data,
;; 56KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1792 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1792, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1792K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 223 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 55.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 220 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 55 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 56*4*clm			;; 56*4*clm iterations
	lea	rbx, [rdi+14*clm*YMM_SCD4]	;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7b				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

	yloop_set_clm_prefetch YSINGLE		;; Prefetch 56 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	14, c9a, -28*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 56*4*clm			;; 56*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	14, c9b, -28*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 56*4*clm			;; 56*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 56 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	28, c7b, -28*clmblkdst8, rdi, 4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 208 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 52 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	896K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	892K	...

;; Do 64 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 112 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 224 cache lines of data (+1/14 due to ineffective L1 prefetching) + 24+52 cache lines of s/c data.
;; A grand total of 20224 bytes -- should fit in a 32KB L1 cache.

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*8]		;; Sin/cos ptr
	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 64*4*clm			;; 56*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 2*4			;; Do 56 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -14*2*clmblkdst8, rdx, 4*8, rdi, 4*YMM_SCND4 ;; 14 iterations!!  Restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 6*2*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD13 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD13 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD13 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*8]		;; Sin/cos ptr
	yloop_init 56*4*clm			;; 56*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; 4 iterations, restore sin/cos pointer
	yloop	14, c5b, -14*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 224
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 224

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	896K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	892K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 112 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 208 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 52 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 224 cache lines of data (+1/4 due to ineffective L1 prefetching) + 52+24 cache lines of s/c data.
;; A grand total of 22784 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 140*4*blkdst		;; We've already prefetched 140 blocks

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*16 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 14*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 64*4*clm			;; 16 or 56 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr7_14cl_28_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD13 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD13 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 2*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4
	yloop	4, b4b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -14*2*clmblkdst8+4*64, rdx, 4*8, rdi, 4*YMM_SCND4 ;; 14 iterations!!  Next source pointer, next sin/cos pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD13 ;; Test loop counter, next source pointer, next sin/cos pointer
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*16-4*clm*4*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE 		;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*16 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 14*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 56*4*clm			;; 56 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; Test loop counter, next source ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	14, b5b, -14*2*clmblkdst8, rdi, -4*4*clm*16 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 220 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 55 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 223 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 55.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD4		;; Premultiplier/sin/cos ptr

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-14*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 56*4*clm			;; 56 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 110*clm cache lines
	yloop_set_alternate_prefetch_increment 174, (110+112)
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YHALF		;; Prefetch 112*clm cache lines
	yloop_set_alternate_prefetch_increment 174, (110+112)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	14, b7a				;; Test loop counter

ELSE

	start_timer 25
	yloop_init 56*4*clm			;; 56 iterations of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 110*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	28, b7b, -28*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -14*clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 56*4*clm			;; 56 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 112*clm cache lines
pfing	bump	rcx, (174-110-112)*clm*64	;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	14, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1792 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 2048 doubles.
;; Memory examples are for a 2048K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*16 + 4*4*clm*YMM_SCND4 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 = 182*clm 64-byte cache lines

;; This pass processes 1024*clm cache lines, or 256KB if clm=4, suggesting we should use clm=1:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc2048 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 2048, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 2048K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 255 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 63.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 252 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 63 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 64*4*clm iterations
	lea	rbx, [rdi+16*clm*YMM_SCD4]	;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7b				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

	yloop_set_clm_prefetch YSINGLE		;; Prefetch 63 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	16, c9b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 63 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	32, c7b, -32*clmblkdst8, rdi, 4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 240 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 60 macros each processing 32 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 64 eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macro processing 32 data values
;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...

;; Do 256 eight_reals_unfft operations
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 due to ineffective L1 prefetching) + 24+16+48 cache lines of s/c data.
;; A grand total of 23040 bytes -- should fit in a 32KB L1 cache.

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*8]		;; Sin/cos ptr
	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rbp+64*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8, rdx, 4*8, rdi, 4*YMM_SCND4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 19
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c2b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c2b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, c2b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c2b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 24 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, c3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD3 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -8*clmblkdst8+4*64, rbp, -16*4*YMM_SCD3 ;; Test loop counter, next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbx, YMM_SCD4, rbp, YMM_SCD3 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*8]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; 4 iterations, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 64*YMM_SCD3		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c2b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c2b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos pointer
	yloop	8, c2b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c2b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 24 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sine/cosine pointer
	yloop	8, c3b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; 2 iterations, restore sine/cosine pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -64*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, c1b				;; 8 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 256
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 256

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 eight_reals_fft operations
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values
;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 64K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 240 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 60 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 or +1/8 due to ineffective L1 prefetching) + 48+16+24 cache lines of s/c data.
;; A grand total of 23040 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, (151-3)*4*blkdst		;; We've already prefetched 151 blocks which will be 3 too many

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rbx, [rbp+64*YMM_SCD3]		;; Sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*16 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YNONE
	yr4_4cl_eight_reals_fft_preload
x64	mov	r9, 4*clmblkdst			;; A short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:
x64	yr4_4cl_eight_reals_fft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, r9 ;; Prefetch a short distance ahead
x32	yr4_4cl_eight_reals_fft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD3 ;; Test loop counter, next sin/cos ptr
x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b1b, -8*clmblkdst8, rbp, -16*4*YMM_SCD3 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b2b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b2b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, b2b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b2b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, b3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4
	yloop	4, b4b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 60 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*2*clmblkdst8+4*64, rdx, 4*8, rdi, 4*YMM_SCND4 ;; Test loop counter, restore source pointer, next sin/cos pointers
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD4, rbp, YMM_SCD3 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*16-4*clm*4*YMM_SCND4 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, b1b, -8*clmblkdst8		;; 8 iterations, restore source pointer
	end_timer 22

	start_timer 23
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b2b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b2b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b2b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b2b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b3b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*16 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; Test loop counter, next source ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 60 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	16, b5b, -16*2*clmblkdst8, rdi, -4*4*clm*16 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 252 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 63 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 255 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 63.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD4		;; Premultiplier/sin/cos ptr

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-16*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 64*4*clm			;; 64 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr. restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 126*clm cache lines
	yloop_set_alternate_prefetch_increment 182, (126+64)
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 182, (126+64)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b7a				;; Test loop counter

ELSE

pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	start_timer 25
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 126*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	32, b7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -16*clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
pfing	bump	rcx, (182-126-64)*clm*64	;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 2048 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 2048 doubles.
;; Memory examples are for a 2048K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*16 + 4*4*clm*YMM_SCND2 + 4*clm*YMM_SCD2 + 16*clm*YMM_SCD4 = 124*clm 64-byte cache lines

;; This pass processes 1024*clm cache lines, or 256KB if clm=4, suggesting we should use clm=1:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc2048ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b3b, b5b, b7a, b7b, b9b, c0b, c1b, c3b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 2048, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 2048K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 256 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+8*clm cache lines of s/c data.
;; A grand total of 15360 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+16*clm*YMM_SCD4]	;; Load second premult/sin/cos pointer
	mov	edx, 4*clmblkdst		;; The distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 64*4*clm			;; 64*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	16, c9b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	32, c7b, -32*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 due to ineffective L1 prefetching) + 12+8+96 cache lines of s/c data.
;; A grand total of 24832 bytes -- should fit in a 32KB L1 cache.

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*8]		;; Sin/cos ptr
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+64*YMM_SCD6]		;; Second sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations

c5a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND2, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND2 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8, rdx, 4*8, rdi, 4*YMM_SCND2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 16*4
	end_timer 18

	start_timer 19
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	2, c3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_set_clm_prefetch YNONE
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4 iterations, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -8*clmblkdst8+4*64, rbp, -16*4*YMM_SCD6 ;; Test loop counter, next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c5a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*16			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*8]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	16, c5b, -16*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	bump	rdi, 64*YMM_SCD6		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos data
	yloop	8, c3b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD2 ;; 2 iterations, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -64*YMM_SCD6		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, c1b				;; 8 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 256
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 256

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 four_complex_first_fft operations
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 or +1/8 due to ineffective L1 prefetching) + 96+8+12 cache lines of s/c data.
;; A grand total of 24832 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 128*4*blkdst		;; We've already prefetched 128 blocks

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+64*YMM_SCD6]		;; Second sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*4*clm*16 + 4*clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Third sin/cos ptr
	lea	rdx, [rdi-4*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YNONE
x64	mov	r9, 4*clmblkdst			;; A short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:
x64	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, r9 ;; Prefetch a short distance ahead
x32	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; Test loop counter, next sin/cos ptr
x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b1b, -8*clmblkdst8, rbp, -16*4*YMM_SCD6 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	2, b3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND2, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*8, rdi, -4*YMM_SCND2 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*2*clmblkdst8+4*64, rdx, 4*8, rdi, 4*YMM_SCND2 ;; Test loop counter, restore source pointer, next sin/cos ptrs
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*16-4*clm*4*YMM_SCND2 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, b1b, -8*clmblkdst8		;; 8 iterations
	end_timer 22

	start_timer 23
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos pointer
	yloop	8, b3b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*4*clm*16 + 4*clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*16]		;; Premultiplier/sin/cos ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 8, rdi, YMM_SCND2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*8, rdi, -4*4*clm*YMM_SCND2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b5b, -16*2*clmblkdst8, rdi, -4*4*clm*16 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 8*clm+4*clm cache lines of s/c data.
;; A grand total of 15360 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD2		;; First sin/cos ptr

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-16*clm*YMM_SCD4]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	mov	edx, 4*clmblkdst		;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 64*4*clm			;; 64 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 124, (64+64)
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, rdx
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 124, (64+64)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b7a				;; Test loop counter

ELSE

	start_timer 25
	yloop_init 64*4*clm			;; 64 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	32, b7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -16*clm*YMM_SCD4		;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 64*4*clm			;; 64 iters of 4*clm
pfing	bump	rcx, (124-64-64)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 2048 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM

ENDIF

;;
;; *****************************  Begin implementation of wpn4 versions of pass 1 macros ******************************
;;

IFDEF YIMPL_WPN4_FFTS

;; Perform a pass 1 FFT of length 128 doubles.
;; Memory examples are for a 128K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 4*clm*YMM_SCD4 = 38*clm 64-byte cache lines

yr4dwpn_pass1sc128 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7b, b8b, b9b, c0b, c1b, c6b, c7b, c8b, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 128, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 128K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 15 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 3.75 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR		;; Get source address
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdx, PREMULT_ADDR	;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]	;; Complex data sin/cos ptr
pfing	lea	rcx, [rdx+(38-16)*clm*64] ;; Finish prefetching the sin/cos/premult data
	yloop_init 4*4*clm		;; 4*4*clm iterations
	yloop_set_prefetch YSINGLE	;; Prefetch 16*clm cache lines
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sine/cosine ptr

	loops_reset
	yloop_set_prefetch YSINGLE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sine/cosine ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4 ;; Loop, next premult/sin/cos pointer
	yloop	2, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9b, -2*clmblkdst8	;; Loop, restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 12 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 3 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c7b, -2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 16
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 16

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 8*4*blkdst		;; We've already prefetched 8 blocks
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 12 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 3 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 4*clm*YMM_SCD4 ;; sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_init 4*4*clm			;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7b,	-2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 15 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 3.75 macros each processing 32 data values

	start_timer 26
	bump	rdi, -4*clm*64-4*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YDOUBLE
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore premult/sine/cosine ptr

	loops_reset
	yloop_set_prefetch YDOUBLE		;; Prefetch 32*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore premult/sine/cosine ptr
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Loop, next premult/sine/cosine pointer
	yloop	2, b9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b9b				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 128 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 128 doubles.
;; Memory examples are for a 128K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD2 + 4*clm*YMM_SCD4 = 28*clm 64-byte cache lines

yr4dwpn_pass1sc128ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b7b, b9b, c0b, c1b, c7b, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 128, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 128K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 16 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR		;; Get source address
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, PREMULT_ADDR	;; Load premult/sin/cos pointer
pfing	lea	rcx, [rdi+(28-16)*clm*64] ;; Finish prefetching the sin/cos/premult data
	yloop_init 4*4*clm		;; 4*4*clm iterations
	yloop_set_prefetch YSINGLE	;; Prefetch 16*clm cache lines
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos data pointer
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4 ;; Test loop counter, next premult/sin/cos pointer
	yloop	2, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9b, -2*clmblkdst8	;; Loop, restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c7b,	-2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...

;; Do 16 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 16
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 16

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 four_complex_first_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 8*4*blkdst		;; We've already prefetched 8 blocks
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 16 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD4	;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 16 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 32 data values

	start_timer 26
	bump	rdi, -4*clm*64-4*clm*YMM_SCD4	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_prefetch YSINGLE		;; Prefetch 16*clm cache lines
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b9b				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 128 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 256 doubles.
;; Memory examples are for a 256K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 = 54*clm 64-byte cache lines

yr4dwpn_pass1sc256 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7b, b8b, b9b, c0b, c1b, c6b, c7b, c8b, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 256, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 256K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 31 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR		;; Get source address
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdx, PREMULT_ADDR	;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]	;; Complex data sin/cos ptr
pfing	lea	rcx, [rdx+(54-32)*clm*64] ;; Finish prefetching the sin/cos/premult data
	yloop_init 8*4*clm		;; 8*4*clm iterations
	yloop_set_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sine/cosine ptr

	loops_reset
	yloop_set_prefetch YSINGLE	;; Prefetch 32*clm cache lines
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sine/cosine ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4 ;; Loop, next premult/sin/cos pointer
	yloop	2, c9b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	4, c9b, -4*clmblkdst8	;; Loop, restore source pointer
	end_timer 16

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 28 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 7 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 8*4*clm			;; 8*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	4, c7b, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...

;; Do 32 sixteen_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 4 macros each processing 64 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 32
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 32

;; Do FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 sixteen_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 64 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 16*4*blkdst	;; We've already prefetched 16 blocks
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iters prefetching 8*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 28 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 7 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 8*clm*YMM_SCD4 ;; sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_init 8*4*clm			;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, b7b,	-4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 31 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 32 data values

	start_timer 26
	bump	rdi, -4*clm*64-8*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 8*4*clm			;; 8 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YSINGLE
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore premult/sine/cosine ptr

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 32*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore premult/sine/cosine ptr
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Loop, next premult/sine/cosine pointer
	yloop	2, b9b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	4, b9b				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 256 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 256 doubles.
;; Memory examples are for a 256K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD2 + 4*clm*YMM_SCD8 = 56*clm 64-byte cache lines

yr4dwpn_pass1sc256ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b7b, b9b, c0b, c1b, c7b, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 256, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 256K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 16 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 64 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR		;; Get source address
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, PREMULT_ADDR	;; Load premult/sin/cos pointer
pfing	lea	rcx, [rdi+(56-32)*clm*64] ;; Finish prefetching the sin/cos/premult data
	yloop_init 4*4*clm		;; 4*4*clm iterations
	yloop_set_prefetch YDOUBLE	;; Prefetch 8 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos data pointer
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -4*clmblkdst8	;; Restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 8*4*clm			;; 8*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, restore sin/cos pointers
	yloop	4, c7b,	-4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...

;; Do 32 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 8 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 32
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 32

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 four_complex_first_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 16*4*blkdst	;; We've already prefetched 16 blocks
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 8 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst	;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 32 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + 4*clm*YMM_SCD8 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_init 8*4*clm			;; 8 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, restore sin/cos ptrs
	yloop	4, b7b, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 16 eight_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 64 data values

	start_timer 26
	bump	rdi, -2*4*clm*64-4*clm*YMM_SCD8	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YDOUBLE		;; Prefetch 32*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 256 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 320 doubles.
;; Memory examples are for a 320K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 10*clm*YMM_SCD4 = 62*clm 64-byte cache lines

;; This pass processes 160*clm cache lines, or 40KB if clm=4, suggesting we should use clm=4:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc320 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9b, c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 320, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 320K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 39 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 36 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 9 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (40*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 10*4*clm			;; 10*4*clm iterations
	lea	rbx, [rdi+10*clm*YMM_SCD4+4*clm*64] ;; Sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst, rdi, clm*YMM_SCD4 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 9 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	5, c9a, -5*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 10*4*clm			;; 10*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	2, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	5, c9b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 10*4*clm			;; 10*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 9 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	5, c7b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...

;; Do 16 twenty_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 80 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 40
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 40

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 80 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, (27-3)*4*blkdst	;; We've already prefetched 27 blocks which will be 3 too many
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	4, b1b, -4*clmblkdst ;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 36 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 9 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 39 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (40*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD2		;; Complex data sin/cos ptr
	lea	rdx, [rbx+10*clm*YMM_SCD4]	;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 10*4*clm			;; 10 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 36*clm cache lines
	yloop_set_alternate_prefetch_increment 62, (36+39)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Loop, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 39*clm cache lines
	yloop_set_alternate_prefetch_increment 62, (36+39)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next src/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 10*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 10*4*clm			;; 10 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 36*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b7b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*64-10*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 10*4*clm			;; 10 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 39*clm cache lines
pfing	bump	rcx, (62-36-39)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter
	yloop	5, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 320 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 384 doubles.
;; Memory examples are for a 384K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 12*clm*YMM_SCD4 = 70*clm 64-byte cache lines

;; This pass processes 192*clm cache lines, or 48KB if clm=4, suggesting we should use clm=4:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc384 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 384, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 384K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 47 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 44 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 11 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 12*4*clm			;; 12*4*clm iterations
	lea	rbx, [rdi+12*clm*YMM_SCD4+4*clm*64] ;; Second sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst, rdi, clm*YMM_SCD4 ;; Test loop counter, restore scratch area pointer, next sin/cos ptr
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, c9a, -6*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	2, c9b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, c9b, -6*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, c7b, -6*clmblkdst8		;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...

;; Do 16 twenty_four_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 96 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 48
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 48

;; Do FFT levels 1,2,3,4,5 (actually 4.565 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_four_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 96 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 32*4*blkdst		;; We've already prefetched 32 blocks
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst		;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 44 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 11 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 47 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD2		;; Complex data sin/cos ptr
	lea	rdx, [rbx+12*clm*YMM_SCD4]	;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 12*4*clm			;; 12 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 2*clm cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 22*clm cache lines
	yloop_set_alternate_prefetch_increment 70, (2+22+47)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
	yloop_set_alternate_prefetch_increment 70, (2+22+47)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 12*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iterations of 4*clm
	yloop_set_prefetch YHALF		;; Prefetch 2*clm cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 22*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, restore source pointer
	yloop	6, b7b, -6*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*64-12*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer

	loops_reset
pfing	bump	rcx, (70-2-22-47)*clm*64	;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest ptrs, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 384 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 384 doubles.
;; Memory examples are for a 384K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD1 + 4*clm*64 + 4*clm*YMM_SCD2 + 4*clm*YMM_SCD4 = 44*clm 64-byte cache lines

;; This pass processes 192*clm cache lines, or 48KB if clm=4, suggesting we should use clm=4:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc384ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 384, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 384K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 48 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 12 macros each processing 32 data values

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD4+4*clm*64] ;; Load second sin/cos pointer
	yloop_init 12*4*clm			;; 12*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	3, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -12*4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	12, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	12, c7b, -12*4*clmblkdst, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 64 three_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 24 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...

;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 48K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4*clm+18 cache lines of s/c data.
;; A grand total of 16000 bytes with clm=4 -- easily fits in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16 or 12 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+12*clmblkdst, rdi, -4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, c5b, -4*12*clmblkdst, rdi, 4*clm*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -3*4*clmblkdst+clmblkdst, rbp, -3*4*YMM_SCD6+YMM_SCD6 ;; Loop 3 times!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter, restore source pointer

ELSE

	start_timer 18
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 12*4*clm			;; 12 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	12, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 48
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 48

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 48 four_complex_first_fft operations
;;	distance between fft data elements is 48K
;;	do 12 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 three_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 18+4*clm cache lines of s/c data.
;; A grand total of 16000 bytes with clm=4 -- easily fits in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 32*4*blkdst		;; We've already prefetched 32 blocks

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 4*clm*64 + 4*clm*YMM_SCD2 + 4*clm*YMM_SCD4
	yloop_init 16*4*clm			;; 12 or 16 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -3*4*clmblkdst, rdi, -3*4*YMM_SCD6+YMM_SCD6 ;; 3 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rbp, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+12*clmblkdst, rbp, -4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, b5b, -4*12*clmblkdst+clmblkdst, rbp, 4*clm*YMM_SCD1 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-4*4*clm*YMM_SCD1-4*clm*YMM_SCD2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	12, b1b, -12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD2 + 4*clm*YMM_SCD4
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -4*clm*YMM_SCD2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 12 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	lea	rbx, [rdx-4*clm*YMM_SCD4]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
	yloop_set_alternate_prefetch_increment 44, (24+24)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
	yloop_set_alternate_prefetch_increment 44, (24+24)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	3, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_prefetch YHALF
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*64-4*clm*YMM_SCD4	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
pfing	bump	rcx, (44-24-24)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	12, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 384 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 448 doubles.
;; Memory examples are for a 448K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 14*clm*YMM_SCD4 = 78*clm 64-byte cache lines

;; This pass processes 224*clm cache lines, or 56KB if clm=4, suggesting we should use clm=4:  56KB of scratch area, 56KB of input FFT data,
;; 56KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc448 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9b, c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 448, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 448K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 55 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 52 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 13 macros each processing 32 data values

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (56*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 14*4*clm			;; 14*4*clm iterations
	lea	rbx, [rdi+14*clm*YMM_SCD4+4*clm*64] ;; Sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 14 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst, rdi, clm*YMM_SCD4 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 13 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	7, c9a, -7*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 14*4*clm			;; 14*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 14 blocks
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	2, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	7, c9b, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 14*4*clm			;; 14*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 13 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	7, c7b, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	224K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	220K	...

;; Do 16 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 112 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 56
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 56

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	224K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	220K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 112 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, (43-3)*4*blkdst	;; We've already prefetched 43 blocks which will be 3 too many
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 52 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 13 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 55 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (56*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD2		;; Complex data sin/cos ptr
	lea	rdx, [rbx+14*clm*YMM_SCD4]	;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 14*4*clm			;; 14 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 26*clm cache lines
	yloop_set_alternate_prefetch_increment 78, (26+55)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 55*clm cache lines
	yloop_set_alternate_prefetch_increment 78, (26+55)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	7, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 14*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 14*4*clm			;; 14 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 26*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	7, b7b, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*64-14*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 14*4*clm			;; 14 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 55*clm cache lines
pfing	bump	rcx, (78-26-55)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	7, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 448 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 512 doubles.
;; Memory examples are for a 512K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 = 86*clm 64-byte cache lines

;; This pass processes 256*clm cache lines, or 64KB if clm=4, suggesting we should use clm=4:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc512 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 512, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 512K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 63 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 60 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 15 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16*4*clm iterations
	lea	rbx, [rdi+16*clm*YMM_SCD4+4*clm*64] ;; Sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst, rdi, clm*YMM_SCD4 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	2, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	8, c9b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	8, c7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...

;; Do 64 eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+12 cache lines of s/c data.
;; A grand total of 19200 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rdi+16*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+2*clmblkdst8 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+2*clmblkdst8 ;; Test loop counter
	yloop	4, c5b, -4*2*clmblkdst8, rbx, YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 18
	loops_undo 4*4*clm

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD3 ;; Test loop counter
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c1b, -2*clmblkdst8+clmblkdst, rdi, -4*4*YMM_SCD3+YMM_SCD3 ;; 2 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 16*YMM_SCD3		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations

	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sine/cosine pointer
	yloop	4, c5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -16*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 64
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 64

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 12+4 cache lines of s/c data.
;; A grand total of 19200 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 40*4*blkdst		;; We've already prefetched 40 blocks

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+16*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, b1b, -2*clmblkdst8, rdi, -4*4*YMM_SCD3+YMM_SCD3 ;; 2 iterations, restore source pointer, next sin/cos ptr
	loops_undo 2*2*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b4b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YHALF
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*2*clmblkdst8+clmblkdst, rbx, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3	;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 60 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 15 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 63 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD2		;; Complex data sin/cos ptr
	lea	rdx, [rbx+16*clm*YMM_SCD4]	;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YHALF		;; Prefetch 30*clm cache lines
	yloop_set_alternate_prefetch_increment 86, (30+63)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
	yloop_set_alternate_prefetch_increment 86, (30+63)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 30*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*64-16*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
pfing	bump	rcx, (86-30-63)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	8, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 512 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 512 doubles.
;; Memory examples are for a 512K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD2 + 4*clm*64 + 4*clm*YMM_SCD2 + 4*clm*YMM_SCD4 = 60*clm 64-byte cache lines

;; This pass processes 256*clm cache lines, or 64KB if clm=4, suggesting we should use clm=4:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc512ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 512, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 512K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 64 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD4+4*clm*64] ;; Load second sin/cos pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	8, c7b, -8*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+2*clmblkdst8, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, c5b, -4*2*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, c1b, -2*clmblkdst8+clmblkdst, rbp, -4*4*YMM_SCD6+YMM_SCD6 ;; 2 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 64
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 64

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 four_complex_first_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 24+8*clm cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 40*4*blkdst		;; We've already prefetched 40 blocks

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 4*clm*64 + 4*clm*YMM_SCD2 + 4*clm*YMM_SCD4
	yloop_init 16*4*clm			;; 16 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, b1b, -2*clmblkdst8, rdi, -4*4*YMM_SCD6+YMM_SCD6 ;; 2 iterations, restore source ptr, next sin/cos ptr
	loops_undo 2*2*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rbp, YMM_SCD2, 4*clm
	yloop	4*clm, b5b, -4*clm*64+2*clmblkdst8, rbp, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, b5b, -4*2*clmblkdst8+clmblkdst, rbp, 4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-4*4*clm*YMM_SCD2-4*clm*YMM_SCD2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD2 + 4*clm*YMM_SCD4
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -4*clm*YMM_SCD2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 16 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	lea	rbx, [rdx-4*clm*YMM_SCD4]	;; Second sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 32*clm cache lines
	yloop_set_alternate_prefetch_increment 60, (32+32)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	yloop_set_prefetch YHALF		;; Prefetch 32*clm cache lines
	yloop_set_alternate_prefetch_increment 60, (32+32)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_prefetch YHALF
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*64-4*clm*YMM_SCD4	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (60-32-32)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 512 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 640 doubles.
;; Memory examples are for a 640K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + 10*clm*YMM_SCD8 = 124*clm 64-byte cache lines
;;
;; IDEA: instead of (20 4 8) we should try (10 4 4 4) with either the first 4 variable or fixed
;; Sin/cos data needed: 4*4*clm*YMM_SCD4 + 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 5*clm*YMM_SCD4 = 106*clm 64-byte cache lines
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 20*clm*YMM_SCD4 = 102*clm 64-byte cache lines

;; This pass processes 320*clm cache lines, or 80KB if clm=4, suggesting we should use clm=4:  80KB of scratch area, 80KB of input FFT data,
;; 80KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc640 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 640, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 640K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 39 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 72 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD4]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 20*4*clm			;; 10*4*clm or 20*4*clm iterations
	lea	rbx, [rdi+10*clm*YMM_SCD8+2*4*clm*64] ;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YSINGLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst, rdi, clm*YMM_SCD8 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	10, c9a, -10*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 10*4*clm			;; 10*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8	;; Test loop counter, next dest pointer, next sin/cos pointer
	yloop	10, c9b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	10, c7b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K	...

;; Do 32 twenty_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 80 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 80
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 80

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 80 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 46*4*blkdst	;; We've already prefetched 46 blocks which will be 2 too few!
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst	;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 72 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 39 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rbx+10*clm*YMM_SCD8]	;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 or 10 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD4]		;; Real data sin/cos ptr
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 72*clm cache lines
	yloop_set_alternate_prefetch_increment 124, (72+78)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YDOUBLE		;; Prefetch 78*clm cache lines
	yloop_set_alternate_prefetch_increment 124, (72+78)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rbx, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	end_timer 26

	yloop	20, b7a				;; 10 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 10*clm*YMM_SCD8 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 72*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	10, b7b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*64-10*clm*YMM_SCD8 ;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD4]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 10*4*clm			;; 10 iters of 4*clm
pfing	bump	rcx, (124-72-78)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YDOUBLE		;; Prefetch 78 cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	yloop	10, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 640 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 640 doubles.
;; Memory examples are for a 640K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD2 + 4*clm*64 + 4*clm*YMM_SCD2 + 4*clm*YMM_SCD4 = 60*clm 64-byte cache lines

;; This pass processes 320*clm cache lines, or 80KB if clm=4, suggesting we should use clm=4:  80KB of scratch area, 80KB of input FFT data,
;; 80KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc640ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 640, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 640K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 80 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 80 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD4+4*clm*64] ;; Load second sin/cos pointer
	yloop_init 20*4*clm			;; 20*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	5, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -20*4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	20, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	20, c7b, -20*4*clmblkdst, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...

;; Do 64 five_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 40 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K	...

;; Do 80 four_complex_unfft operations
;;	distance between fft data elements is 80K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 16 or 20 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+20*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	8, c5b, -4*20*clmblkdst, rdi, 4*clm*YMM_SCD2 ;; 4 iterations!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -5*4*clmblkdst+clmblkdst, rbp, -5*4*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+20*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	20, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 80
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 80

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...

;; Do 80 four_complex_first_fft operations
;;	distance between fft data elements is 80K
;;	do 20 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 five_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 40 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 30+8*clm cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 44*4*blkdst		;; We've already prefetched 44 blocks

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 4*clm*64 + 4*clm*YMM_SCD2 + 4*clm*YMM_SCD4
	yloop_init 32*4*clm			;; 20 or 16 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -5*4*clmblkdst, rdi, -5*4*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, 4*clmblkdst, rbp, YMM_SCD2, 4*clm
	yloop	4*clm, b5b, -4*clm*64+20*clmblkdst, rbp, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	8, b5b, -4*20*clmblkdst+clmblkdst, rbp, 4*clm*YMM_SCD2 ;; 4 iterations!! next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-4*4*clm*YMM_SCD2-4*clm*YMM_SCD2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	20, b1b, -20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD2 + 4*clm*YMM_SCD4
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+20*clmblkdst, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -4*clm*YMM_SCD2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 80 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 20 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 80 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	lea	rbx, [rdx-4*clm*YMM_SCD4]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 40*clm cache lines
	yloop_set_alternate_prefetch_increment 60, (40+20)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer. restore sin/cos ptrs
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
	yloop_set_alternate_prefetch_increment 60, (40+20)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	5, b7a				;; Test loop counter
	bump	rbx, clm*YMM_SCD4		;; Next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_prefetch YHALF		;; Prefetch 40*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	20, b7b, -20*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*64-4*clm*YMM_SCD4	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
pfing	bump	rcx, (60-40-20)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	20, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 640 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 768 doubles.
;; Memory examples are for a 768K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + 12*clm*YMM_SCD8 = 140*clm 64-byte cache lines

;; This pass processes 384*clm cache lines, or 96KB if clm=4, suggesting we should use clm=2:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc768 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 768, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 768K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 47 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 88 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 22 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD4]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 24*4*clm			;; 12*4*clm or 24*4*clm iterations
	lea	rbx, [rdi+12*clm*YMM_SCD8+2*4*clm*64] ;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YDOUBLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 24 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst, rdi, clm*YMM_SCD8 ;; Test loop counter, restore scratch area pointer, next sin/cos ptr
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	12, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+2*4*clm*YMM_SCD4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YDOUBLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 24 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next dest pointer, next sin/cos pointer
	yloop	12, c9b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 24*4*clm			;; 24*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	12, c7b, -12*clmblkdst8, rdi, 2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...

;; Do 32 twenty_four_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 96 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 96
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 96

;; Do FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_four_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 96 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 64*4*blkdst		;; We've already prefetched 64 blocks
	yloop_init 8*4*clm			;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD		;; Prefetch 32 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst		;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 72 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 47 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rbx+12*clm*YMM_SCD8]	;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 or 12 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YSINGLE		;; Prefetch 8*clm cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD4]		;; Real data sin/cos ptr
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 88*clm cache lines
	yloop_set_alternate_prefetch_increment 140, (8+88+47)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
	yloop_set_alternate_prefetch_increment 140, (8+88+47)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rbx, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	end_timer 26

	yloop	24, b7a				;; 12 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 12*clm*YMM_SCD8 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 iterations of 4*clm
	yloop_set_prefetch YSINGLE		;; Prefetch 8*clm cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 88*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*64-4*clm*YMM_SCD8	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD4]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
pfing	bump	rcx, (140-8-88-47)*clm*64	;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	yloop	12, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 768 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 768 doubles.
;; Memory examples are for a 768K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 8*4*clm*YMM_SCD1 + 2*4*clm*64 + 2*4*clm*YMM_SCD2 + 4*clm*YMM_SCD8 = 88*clm 64-byte cache lines

;; This pass processes 384*clm cache lines, or 96KB if clm=4, suggesting we should use clm=2:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This ought to fit in 256KB L2 cache.

yr4dwpn_pass1sc768ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 768, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 768K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 48 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines of input FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- marginally fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD8+2*4*clm*64] ;; Load second sin/cos pointer
	yloop_init 24*4*clm			;; 12*4*clm or 24*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	3, c9a, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+2*4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	3, c9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 24*4*clm			;; 24*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	12, c7b, -12*clmblkdst8, rdi, 2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...

;; Do 128 three_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 24 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...

;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 96K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+100% prefetching next scratch area section) + 4*clm+24 cache lines of s/c data.
;; A grand total of 27136 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 32 or 24 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, clmblkdst8, rdi, YMM_SCD1, 4*clm
	yloop	4*clm, c5b, -4*clm*64+3*clmblkdst8, rdi, -4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, c5b, -4*3*clmblkdst8, rdi, 4*clm*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -3*clmblkdst8+clmblkdst, rbp, -3*8*YMM_SCD6+YMM_SCD6 ;; Loop 3 times!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, clmblkdst8, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+3*clmblkdst8, rdi, -8*4*clm*YMM_SCD1 ;; 8 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 24*4*clm			;; 24 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8	;; Test loop counter
	yloop	3, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 96
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 96

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...

;; Do 96 four_complex_first_fft operations
;;	distance between fft data elements is 96K
;;	do 24 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 three_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+100% prefetching next scratch area section) + 24+4*clm cache lines of s/c data.
;; A grand total of 27136 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 64*4*blkdst		;; We've already prefetched 64 blocks

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 2*4*clm*64 + 2*4*clm*YMM_SCD2 + 4*clm*YMM_SCD8
	yloop_init 32*4*clm			;; 24 or 32 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -3*clmblkdst8, rdi, -3*8*YMM_SCD6+YMM_SCD6 ;; 3 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, clmblkdst8, rbp, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+3*clmblkdst8, rbp, -4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, b5b, -4*3*clmblkdst8+clmblkdst, rbp, 4*clm*YMM_SCD1 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-8*4*clm*YMM_SCD1-2*4*clm*YMM_SCD2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 24*4*clm			;; 24 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	3, b1b, -3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 2*4*clm*64 + 2*4*clm*YMM_SCD2 + 4*clm*YMM_SCD8
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, clmblkdst8, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, b5b, -8*clmblkdst+3*clmblkdst8, rdi, -8*4*clm*YMM_SCD1 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -2*4*clm*YMM_SCD2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 96 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 24 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 48 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	lea	rbx, [rdx-4*clm*YMM_SCD8]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 or 12 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 88, (48+48)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YSINGLE		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 88, (48+48)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	6, b7a, 0, rbx, clm*YMM_SCD8	;; 3 iterations!!!  Next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 iters of 4*clm
	yloop_set_prefetch YHALF		;; Prefetch 48*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*64-4*clm*YMM_SCD8	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (88-48-48)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YSINGLE		;; Prefetch 48*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	3, b9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 768 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 896 doubles.
;; Memory examples are for a 896K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + 14*clm*YMM_SCD8 = 156*clm 64-byte cache lines
;; 
;; or would 14 4 4 4 be better than the implemented 28 4 8:
;; Sin/cos data needed: 4*4*clm*YMM_SCD4 + 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 7*clm*YMM_SCD4 = 114*clm 64-byte cache lines

;; This pass processes 448*clm cache lines, or 112KB if clm=4, suggesting we should use clm=2:  56KB of scratch area, 56KB of input FFT data,
;; 56KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc896 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9b, c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 896, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 896K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 55 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 104 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 26 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD4]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (112*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 28*4*clm			;; 14*4*clm or 28*4*clm iterations
	lea	rbx, [rdi+14*clm*YMM_SCD8+2*4*clm*64] ;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YDOUBLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 28 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst, rdi, clm*YMM_SCD8 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 26 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	14, c9a, -14*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 14*4*clm			;; 14*4*clm iterations
	yloop_set_clm_prefetch YDOUBLE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 28 blocks
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8	;; Test loop counter, next dest pointer, next sin/cos pointer
	yloop	14, c9b, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 28*4*clm			;; 28*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 26 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	14, c7b, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	448K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	444K	...

;; Do 32 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 112 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 112
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 112

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	448K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	444K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_eight_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 112 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, (86-6)*4*blkdst	;; We've already prefetched 86 blocks which will be 6 too many
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 104 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 26 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 55 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (112*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rbx+14*clm*YMM_SCD8]	;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 28*4*clm			;; 28 or 14 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yloop_set_alternate_prefetch_increment 155, (104+55)
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD4]		;; Real data sin/cos ptr
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 104*clm cache lines
	yloop_set_alternate_prefetch_increment 155, (104+55)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 55*clm cache lines
	yloop_set_alternate_prefetch_increment 155, (104+55)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rbx, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	end_timer 26

	yloop	28, b7a				;; 14 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 14*clm*YMM_SCD8 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 28*4*clm			;; 28 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 104*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	14, b7b, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*64-14*clm*YMM_SCD8 ;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD4]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 14*4*clm			;; 14 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 55*clm cache lines
pfing	bump	rcx, (156-104-55)*clm*64	;; Finish prefetching the sin/cos/premult data
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	yloop	14, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 896 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1024 doubles.
;; Memory examples are for a 1024K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + 16*clm*YMM_SCD8 = 172*clm 64-byte cache lines

;; This pass processes 512*clm cache lines, or 128KB if clm=4, suggesting we should use clm=2:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc1024 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1024, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1024K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 63 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 120 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 30 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD4]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 16*4*clm or 32*4*clm iterations
	lea	rbx, [rdi+16*clm*YMM_SCD8+2*4*clm*64] ;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst, rdi, clm*YMM_SCD8 ;; Test loop counter, restore scratch area pointer, next sin/cos pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	16, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr8_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8	;; Test loop counter, next dest pointer, next sin/cos pointer
	yloop	16, c9b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	16, c7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macro processing 32 data values
;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...

;; Do 128 eight_reals_unfft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+12 cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rdi+32*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+4*clmblkdst8 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+4*clmblkdst8 ;; Test loop counter
	yloop	4, c5b, -4*4*clmblkdst8, rbx, YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 18
	loops_undo 4*4*clm

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD3 ;; Test loop counter
	yloop	4, c1b, -4*clmblkdst8+clmblkdst, rdi, -4*8*YMM_SCD3+YMM_SCD3 ;; 4 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 32*YMM_SCD3		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations

	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, c4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; 8 iterations, restore sine/cosine pointer
	yloop	4, c5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -32*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 128
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 128

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 eight_reals_fft operations
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values
;; Do 96 four_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 12+4 cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 80*4*blkdst		;; We've already prefetched 80 blocks

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+32*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD3 ;; 4*clm iters, next source ptr, next sin/cos ptr
	yloop	4, b1b, -4*clmblkdst8, rdi, -4*8*YMM_SCD3+YMM_SCD3 ;; 4 iterations, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b4b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*4*clmblkdst8+clmblkdst, rbx, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3	;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, b1b, -4*clmblkdst8		;; 4 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 120 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 30 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 63 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbx, PREMULT_ADDR		;; Real data sin/cos ptr
	bump	rbx, clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rbx+16*clm*YMM_SCD8]	;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 or 16 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD4]		;; Real data sin/cos ptr
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YSINGLE		;; Prefetch 120*clm cache lines
	yloop_set_alternate_prefetch_increment 172, (120+63)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
	yloop_set_alternate_prefetch_increment 172, (120+63)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rbx, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	end_timer 26

	yloop	32, b7a				;; 16 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 16*clm*YMM_SCD8 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 120*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*64-16*clm*YMM_SCD8 ;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD4]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (172-120-64)*clm*64	;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YSINGLE		;; Prefetch 1*clm cache lines
b8b:	yr8_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8, rdi, clm*YMM_SCD8 ;; Test loop counter, next source pointer, next premult/sine/cosine pointer
	yloop	16, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1024 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 1024 doubles.
;; Memory examples are for a 1024K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 8*4*clm*YMM_SCD2 + 2*4*clm*64 + 2*4*clm*YMM_SCD2 + 4*clm*YMM_SCD8 = 120*clm 64-byte cache lines

;; This pass processes 512*clm cache lines, or 128KB if clm=4, suggesting we should use clm=2:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc1024ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 1024, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1024K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 64 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines of input FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- marginally fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD8+2*4*clm*64] ;; Load second premult/sin/cos pointer
	yloop_init 32*4*clm			;; 16*4*clm or 32*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	4, c9a, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+2*4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	4, c9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	16, c7b, -16*clmblkdst8, rdi, 2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 32*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+4*clmblkdst8, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, c5b, -4*4*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -4*clmblkdst8+clmblkdst, rbp, -4*8*YMM_SCD6+YMM_SCD6 ;; 4 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; 8 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 128
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 128

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 four_complex_first_fft operations
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 four_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 80*4*blkdst		;; We've already prefetched 80 blocks

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 8*clm*64 + 8*clm*YMM_SCD2 + 4*clm*YMM_SCD8
	yloop_init 32*4*clm			;; 32 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst8, rdi, -4*8*YMM_SCD6+YMM_SCD6 ;; 4 iterations, restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbp, YMM_SCD2, 4*clm
	yloop	4*clm, b5b, -4*clm*64+4*clmblkdst8, rbp, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	4, b5b, -4*4*clmblkdst8+clmblkdst, rbp, 4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-8*4*clm*YMM_SCD2-8*clm*YMM_SCD2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, b1b, -4*clmblkdst8		;; 4 iterations
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 8*clm*64 + 8*clm*YMM_SCD2 + 4*clm*YMM_SCD8
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, b5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -8*clm*YMM_SCD2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 128 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 64 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	lea	rbx, [rdx-4*clm*YMM_SCD8]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 or 16 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 120, (64+64)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YSINGLE		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 120, (64+64)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	8, b7a, 0, rbx, clm*YMM_SCD8	;; 4 iterations!!!  Next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_prefetch YHALF		;; Prefetch 64*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*64-4*clm*YMM_SCD8	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (120-64-64)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YSINGLE		;; Prefetch 64*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, b9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1024 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1280 doubles.
;; Memory examples are for a 1280K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD4 + 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 10*clm*YMM_SCD4 = 126*clm 64-byte cache lines

;; This pass processes 640*clm cache lines, or 160KB if clm=4, suggesting we should use clm=1:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1280 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1280, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1280K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 159 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 39.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 156 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 39 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 40*4*clm			;; 40*4*clm iterations
	lea	rbx, [rdi+10*clm*YMM_SCD4+4*clm*64] ;; Sin/cos ptr
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7b				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	10, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	10, c9b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	20, c7b, -20*clmblkdst8, rdi, 4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 144 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 36 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K	...

;; Do 64 twenty_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 80 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 160 cache lines of data (+1/10 due to ineffective L1 prefetching) + 24+52 cache lines of s/c data.
;; A grand total of 16128 bytes -- should fit in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 64*4*clm			;; 40*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 6*4			;; Do 40 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -10*2*clmblkdst8, rdi, 4*YMM_SCD4 ;; 10 iterations!!  Restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 12*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD9 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD9 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD9 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	10, c5b, -10*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 160
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 160

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 80 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 144 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 36 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 160 cache lines of data (+1/4 due to ineffective L1 prefetching) + 36+16 cache lines of s/c data.
;; A grand total of 16128 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 92*4*blkdst		;; We've already prefetched 92 blocks

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 10*clm*YMM_SCD4 ;; Sin/cos ptr
	yloop_init 64*4*clm			;; 16 or 40 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr5_10cl_20_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD9 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD9 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 6*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4
	yloop	4, b4b, -4*64+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -10*2*clmblkdst8+4*64, rdi, 4*YMM_SCD4 ;; 10 iterations!!  Next source pointer, next sin/cos pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD9 ;; Test loop counter, next source pointer, next sin/cos pointer
	yloop	4, b1a, -4*clmblkdst, rdi, -4*clm*4*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 10*clm*YMM_SCD4 ;; Sin/cos ptr
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; Test loop counter, next source ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	10, b5b, -10*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 156 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 39 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 159 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 39.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD4		;; Sin/cos ptr

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	lea	rbx, [rdx-10*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 40*4*clm			;; 40 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 78*clm cache lines
	yloop_set_alternate_prefetch_increment 126, (78+80)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YHALF		;; Prefetch 80*clm cache lines
	yloop_set_alternate_prefetch_increment 126, (78+80)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	10, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 78*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	20, b7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*64-10*clm*YMM_SCD4	;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 40*4*clm			;; 40 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 80*clm cache lines
pfing	bump	rcx, (126-78-80)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	10, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1280 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 1280 doubles.
;; Memory examples are for a 1280K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 8*4*clm*YMM_SCD2 + 2*4*clm*64 + 2*4*clm*YMM_SCD2 + 4*clm*YMM_SCD8 = 120*clm 64-byte cache lines

;; This pass processes 640*clm cache lines, or 160KB if clm=4, suggesting we should use clm=1:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1280ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 1280, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1280K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 80 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 160 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+4*clm*YMM_SCD8+2*4*clm*64] ;; Load second sin/cos pointer
	yloop_init 40*4*clm			;; 20*4*clm or 40*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	5, c9a, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+2*4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9b:	yr8_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdi, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	5, c9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sin/cos pointer
	yloop	4, c9b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	20, c7b, -20*clmblkdst8, rdi, 2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...

;; Do 128 five_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 40 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K	...

;; Do 160 four_complex_unfft operations
;;	distance between fft data elements is 160K
;;	do 40 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 32 or 40 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr

c5a:	start_timer 18
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+5*clmblkdst8, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	8, c5b, -4*5*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; 4 iterations!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -5*clmblkdst8+clmblkdst, rbp, -5*8*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+5*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	5, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 160
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 160

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...

;; Do 160 four_complex_first_fft operations
;;	distance between fft data elements is 160K
;;	do 40 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 five_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 40 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 88*4*blkdst		;; We've already prefetched 88 blocks

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, PREMULT_ADDR		;; Address of sin/cos table
	bump	rbp, 2*4*clm*64 + 2*4*clm*YMM_SCD2 + 4*clm*YMM_SCD8
	yloop_init 64*4*clm			;; 40 or 32 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch a short distance ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters
	yloop	8, b1b, -5*clmblkdst8, rdi, -5*8*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, clmblkdst8, rbp, YMM_SCD2, 4*clm
	yloop	4*clm, b5b, -4*clm*64+5*clmblkdst8, rbp, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptr
	yloop	8, b5b, -4*5*clmblkdst8+clmblkdst, rbp, 4*clm*YMM_SCD2 ;; 4 iterations!! next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer
	lea	rdi, [rbp-8*4*clm*YMM_SCD2-2*4*clm*YMM_SCD2] ;; Next sin/cos ptr

ELSE

	start_timer 22
	yloop_init 40*4*clm			;; 40 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	5, b1b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 2*4*clm*64 + 2*4*clm*YMM_SCD2 + 4*clm*YMM_SCD8
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, clmblkdst8, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	8, b5b, -8*clmblkdst+5*clmblkdst8, rdi, -8*4*clm*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24
	bump	rdi, -2*4*clm*YMM_SCD2		;; Next sin/cos ptr

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 160 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 80 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	lea	rbx, [rdx-4*clm*YMM_SCD8]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 or 20 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 80*clm cache lines
	yloop_set_alternate_prefetch_increment 120, (80+40)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YHALF		;; Prefetch 40*clm cache lines
	yloop_set_alternate_prefetch_increment 120, (80+40)
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rbx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rbx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	10, b7a, 0, rbx, clm*YMM_SCD8	;; 5 iterations!!!  Next premult/sine/cosine pointer
	yloop	4, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 iters of 4*clm
	yloop_set_prefetch YHALF		;; Prefetch 80*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	20, b7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -2*4*clm*64-4*clm*YMM_SCD8	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
pfing	bump	rcx, (120-80-40)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF		;; Prefetch 40*clm cache lines
b9b:	yr8_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdi, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdi, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b9b, 0, rdi, clm*YMM_SCD8	;; Test loop counter, next premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1280 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1536 doubles.
;; Memory examples are for a 1536K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*64 + 4*4*clm*YMM_SCD4 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 12*clm*YMM_SCD4 = 146*clm 64-byte cache lines

;; This pass processes 768*clm cache lines, or 192KB if clm=4, suggesting we should use clm=1:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1536 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1536, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1536K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 191 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 47.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 188 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 47 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 48*4*clm			;; 48*4*clm iterations
	lea	rbx, [rdi+12*clm*YMM_SCD4]	;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7b				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	12, c9a, -24*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	12, c9b, -24*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	24, c7b, -24*clmblkdst8, rdi, 4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 176 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 44 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...

;; Do 64 twenty_four_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 96 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/12 due to ineffective L1 prefetching) + 24+44 cache lines of s/c data.
;; A grand total of 17664 bytes -- should fit in a 32KB L1 cache.

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 64*4*clm			;; 48*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 4*4			;; Do 48 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -12*2*clmblkdst8, rdx, 4*32, rdi, 4*YMM_SCD4 ;; 12 iterations!!  Restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 6*2*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD11 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD11 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD11 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	12, c5b, -12*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 192
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 192

;; Do FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_four_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 96 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 176 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 44 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/4 due to ineffective L1 prefetching) + 44+24 cache lines of s/c data.
;; A grand total of 19712 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 128*4*blkdst		;; We've already prefetched 128 blocks

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 12*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 16 or 48 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr6_12cl_24_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD11 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD11 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 4*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4
	yloop	4, b4b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -12*2*clmblkdst8+4*64, rdx, 4*32, rdi, 4*YMM_SCD4 ;; 12 iterations!!  Next source pointer, next sin/cos pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD11 ;; Test loop counter, next source pointer, next sin/cos pointer
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*64-4*clm*4*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 12*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; Test loop counter, next source ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b5b, -12*2*clmblkdst8, rdi, -4*4*clm*64 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 188 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 47 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 191 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 47.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD4		;; Premultiplier/sin/cos ptr

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-12*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 94*clm cache lines
	yloop_set_alternate_prefetch_increment 146, (94+96)
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YHALF		;; Prefetch 96*clm cache lines
	yloop_set_alternate_prefetch_increment 146, (94+96)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	12, b7a				;; Test loop counter

ELSE

	start_timer 25
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 94*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	24, b7b, -24*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -12*clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 96*clm cache lines
pfing	bump	rcx, (146-94-96)*clm*64		;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	12, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1536 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 1536 doubles.
;; Memory examples are for a 1536K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD1 + 4*clm*64 + 4*clm*YMM_SCD2 + 16*clm*YMM_SCD4 = 92*clm 64-byte cache lines

;; This pass processes 768*clm cache lines, or 192KB if clm=4, suggesting we should use clm=1:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1536ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b3a, b3b, b5b, b7a, b7b, b9b, c0b, c1b, c3a, c3b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 1536, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1536K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 192 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+16*clm*YMM_SCD4+4*clm*64] ;; Load second sin/cos pointer
	yloop_init 48*4*clm			;; 48*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	3, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	16, c9a, -48*4*clmblkdst	;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	12, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	16, c9b, -192*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	48, c7b, -48*4*clmblkdst, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 256 three_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 24 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 48K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 192K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/16 due to ineffective L1 prefetching) + 4+6+72 cache lines of s/c data.
;; A grand total of 18304 bytes -- easily fitting in a 32KB L1 cache.

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 64*4*clm or 48*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+48*YMM_SCD6]		;; Second sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4, L1PREFETCH_ALL, 12*clmblkdst ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD1 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*12*clmblkdst, rdi, 4*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 16*4
	end_timer 18

	start_timer 19
c3a:	yloop_adjust 4				;; Fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	4, c3b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD2 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer
	yloop	4, c3a, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_adjust 4*4			;; Fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4 iterations, next sin/cos ptr
	yloop	16, c1b, -12*4*clmblkdst+4*64, rbp, -12*4*YMM_SCD6 ;; 12 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c5a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos pointer
	yloop	16, c5b, -16*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	bump	rdi, 48*YMM_SCD6		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos data
	yloop	12, c3b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD2 ;; 2 iterations, restore sin/cos pointer
	yloop	4, c3b, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -48*YMM_SCD6		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	48, c1b				;; 48 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 192
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 192

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...

;; Do 192 four_complex_first_fft operations
;;	distance between fft data elements is 192K
;;	do 48 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 48K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	48K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 three_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/12 due to ineffective L1 prefetching) + 4+6+72 cache lines of s/c data.
;; A grand total of 18560 bytes -- easily fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 144*4*blkdst		;; We've already prefetched 144 blocks

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+48*YMM_SCD6]		;; Second sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD2 + 16*clm*YMM_SCD4
	yloop_init 64*4*clm			;; 48 or 64 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 4*4			;; Fewer iterations this loop
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rbp, 0, 4, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; Test loop counter, next sin/cos ptr
	yloop	16, b1b, -12*4*clmblkdst, rbp, -12*4*YMM_SCD6 ;; 12 iterations!!  Restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
b3a:	yloop_adjust 4				;; Fewer iterations this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	4, b3b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD2 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer
	yloop	4, b3a, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4
	yloop	4, b5b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD1 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*12*clmblkdst+4*64, rdi, 4*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, b1a, -4*clmblkdst, rdi, -4*clm*4*YMM_SCD1 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	48, b1b, -48*clmblkdst		;; 48 iterations
	end_timer 22

	start_timer 23
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos pointer
	yloop	12, b3b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b3b, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD2 + 16*clm*YMM_SCD4
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	16, b5b, -16*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD2		;; First sin/cos ptr

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	lea	rbx, [rdx-16*clm*YMM_SCD4]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 92, (48+48)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 92, (48+48)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	3, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b7a				;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	48, b7b, -48*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*64-16*clm*YMM_SCD4	;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm
pfing	bump	rcx, (92-48-48)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	12, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1536 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1792 doubles.
;; Memory examples are for a 1792K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*64 + 4*4*clm*YMM_SCD4 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 14*clm*YMM_SCD4 = 154*clm 64-byte cache lines

;; This pass processes 896*clm cache lines, or 224KB if clm=4, suggesting we should use clm=1:  56KB of scratch area, 56KB of input FFT data,
;; 56KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1792 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1792, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1792K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 223 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 55.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 220 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 55 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 56*4*clm			;; 56*4*clm iterations
	lea	rbx, [rdi+14*clm*YMM_SCD4]	;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7b				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

	yloop_set_clm_prefetch YSINGLE		;; Prefetch 56 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	14, c9a, -28*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 56*4*clm			;; 56*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	14, c9b, -28*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 56*4*clm			;; 56*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 56 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	28, c7b, -28*clmblkdst8, rdi, 4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 208 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 52 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	896K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	892K	...

;; Do 64 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 112 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 224 cache lines of data (+1/14 due to ineffective L1 prefetching) + 24+52 cache lines of s/c data.
;; A grand total of 20224 bytes -- should fit in a 32KB L1 cache.

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 64*4*clm			;; 56*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 2*4			;; Do 56 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -14*2*clmblkdst8, rdx, 4*32, rdi, 4*YMM_SCD4 ;; 14 iterations!!  Restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 6*2*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD13 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD13 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD13 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	yloop_init 56*4*clm			;; 56*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	14, c5b, -14*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 224
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 224

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	896K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	892K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 112 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 208 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 52 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 224 cache lines of data (+1/4 due to ineffective L1 prefetching) + 52+24 cache lines of s/c data.
;; A grand total of 22784 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 140*4*blkdst		;; We've already prefetched 140 blocks

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 14*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 16 or 56 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr7_14cl_28_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD13 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD13 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 2*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4
	yloop	4, b4b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -14*2*clmblkdst8+4*64, rdx, 4*32, rdi, 4*YMM_SCD4 ;; 14 iterations!!  Next source pointer, next sin/cos pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD13 ;; Test loop counter, next source pointer, next sin/cos pointer
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*64-4*clm*4*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE 		;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 14*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 56*4*clm			;; 56 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; Test loop counter, next source ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	14, b5b, -14*2*clmblkdst8, rdi, -4*4*clm*64 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 220 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 55 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 223 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 55.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD4		;; Premultiplier/sin/cos ptr

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-14*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 56*4*clm			;; 56 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 110*clm cache lines
	yloop_set_alternate_prefetch_increment 154, (110+56)
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 56*clm cache lines
	yloop_set_alternate_prefetch_increment 154, (110+56)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	14, b7a				;; Test loop counter

ELSE

	start_timer 25
	yloop_init 56*4*clm			;; 56 iterations of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 110*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	28, b7b, -28*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -14*clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 56*4*clm			;; 56 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 56*clm cache lines
pfing	bump	rcx, (154-110-56)*clm*64	;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	14, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1792 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 2048 doubles.
;; Memory examples are for a 2048K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*64 + 4*4*clm*YMM_SCD4 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 = 162*clm 64-byte cache lines

;; This pass processes 1024*clm cache lines, or 256KB if clm=4, suggesting we should use clm=1:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc2048 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7b, c7c, c8b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 2048, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 2048K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 255 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 63.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 252 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 63 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdx, PREMULT_ADDR		;; Real data sin/cos pointer
	lea	rdi, [rdx+clm*YMM_SCD2]		;; Complex data sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 64*4*clm iterations
	lea	rbx, [rdi+16*clm*YMM_SCD4]	;; Sin/cos ptr

	start_timer 16
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	end_timer 16

	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).

	loops_reset
c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7b				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

	yloop_set_clm_prefetch YSINGLE		;; Prefetch 63 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
c8b:	yr4_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next sin/cos pointer
	yloop	16, c9b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 63 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	32, c7b, -32*clmblkdst8, rdi, 4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 240 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 60 macros each processing 32 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 64 eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macro processing 32 data values
;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...

;; Do 256 eight_reals_unfft operations
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 due to ineffective L1 prefetching) + 24+16+48 cache lines of s/c data.
;; A grand total of 23040 bytes -- should fit in a 32KB L1 cache.

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rbp+64*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8, rdx, 4*32, rdi, 4*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 19
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c2b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c2b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, c2b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c2b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 24 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, c3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD3 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -8*clmblkdst8+4*64, rbp, -16*4*YMM_SCD3 ;; Test loop counter, next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbx, YMM_SCD4, rbp, YMM_SCD3 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 64*YMM_SCD3		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c2b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c2b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos pointer
	yloop	8, c2b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c2b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 24 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sine/cosine pointer
	yloop	8, c3b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; 2 iterations, restore sine/cosine pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -64*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, c1b				;; 8 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 256
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 256

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 eight_reals_fft operations
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values
;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 64K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 240 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 60 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 or +1/8 due to ineffective L1 prefetching) + 48+16+24 cache lines of s/c data.
;; A grand total of 23040 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, (151-3)*4*blkdst		;; We've already prefetched 151 blocks which will be 3 too many

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rbx, [rbp+64*YMM_SCD3]		;; Sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YNONE
	yr4_4cl_eight_reals_fft_preload
x64	mov	r9, 4*clmblkdst			;; A short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:
x64	yr4_4cl_eight_reals_fft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, r9 ;; Prefetch a short distance ahead
x32	yr4_4cl_eight_reals_fft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD3 ;; Test loop counter, next sin/cos ptr
x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b1b, -8*clmblkdst8, rbp, -16*4*YMM_SCD3 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b2b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b2b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, b2b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b2b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, b3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4
	yloop	4, b4b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 60 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*2*clmblkdst8+4*64, rdx, 4*32, rdi, 4*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointers
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD4, rbp, YMM_SCD3 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*64-4*clm*4*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, b1b, -8*clmblkdst8		;; 8 iterations, restore source pointer
	end_timer 22

	start_timer 23
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b2b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b2b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b2b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b2b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b3b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; Test loop counter, next source ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 60 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	16, b5b, -16*2*clmblkdst8, rdi, -4*4*clm*64 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 252 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 63 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 255 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 63.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD4		;; Premultiplier/sin/cos ptr

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-16*clm*YMM_SCD4]	;; Complex data sin/cos ptr
	lea	rdx, [rbx-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 64*4*clm			;; 64 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr. restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	mov	edx, 4*clmblkdst		;; Use the now available rdx register to hold the distance to the next portion of the
						;; scratch area we will process (so we can prefetch it into the L1 cache).
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 126*clm cache lines
	yloop_set_alternate_prefetch_increment 162, (126+64)
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, rdx
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 162, (126+64)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b7a				;; Test loop counter

ELSE

pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	start_timer 25
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 126*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	32, b7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -16*clm*YMM_SCD4		;; Complex data sin/cos ptr
	lea	rdx, [rdi-clm*YMM_SCD2]		;; Real data sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
pfing	bump	rcx, (162-126-64)*clm*64	;; Finish prefetching the sin/cos/premult data
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 2048 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 2048 doubles.
;; Memory examples are for a 2048K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*64 + 4*4*clm*YMM_SCD2 + 4*clm*YMM_SCD2 + 16*clm*YMM_SCD4 = 120*clm 64-byte cache lines

;; This pass processes 1024*clm cache lines, or 256KB if clm=4, suggesting we should use clm=1:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc2048ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b3b, b5b, b7a, b7b, b9b, c0b, c1b, c3b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 2048, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 2048K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 256 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+8*clm cache lines of s/c data.
;; A grand total of 15360 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+16*clm*YMM_SCD4]	;; Load second premult/sin/cos pointer
	mov	edx, 4*clmblkdst		;; The distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 64*4*clm			;; 64*4*clm iterations

c9a:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, rdx ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9a, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_sg4cl_four_complex_unfft4_preload
c9b:	yr4_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sin/cos pointer
	yloop	16, c9b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	32, c7b, -32*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 due to ineffective L1 prefetching) + 12+8+96 cache lines of s/c data.
;; A grand total of 24832 bytes -- should fit in a 32KB L1 cache.

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+64*YMM_SCD6]		;; Second sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations

c5a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8, rdx, 4*32, rdi, 4*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 16*4
	end_timer 18

	start_timer 19
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	2, c3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_set_clm_prefetch YNONE
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4 iterations, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -8*clmblkdst8+4*64, rbp, -16*4*YMM_SCD6 ;; Test loop counter, next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c5a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	16, c5b, -16*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	bump	rdi, 64*YMM_SCD6		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos data
	yloop	8, c3b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD2 ;; 2 iterations, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -64*YMM_SCD6		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, c1b				;; 8 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 256
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 256

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 four_complex_first_fft operations
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 or +1/8 due to ineffective L1 prefetching) + 96+8+12 cache lines of s/c data.
;; A grand total of 24832 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 128*4*blkdst		;; We've already prefetched 128 blocks

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+64*YMM_SCD6]		;; Second sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Third sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YNONE
x64	mov	r9, 4*clmblkdst			;; A short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:
x64	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, r9 ;; Prefetch a short distance ahead
x32	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; Test loop counter, next sin/cos ptr
x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b1b, -8*clmblkdst8, rbp, -16*4*YMM_SCD6 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	2, b3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*2*clmblkdst8+4*64, rdx, 4*32, rdi, 4*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptrs
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*64-4*clm*4*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, b1b, -8*clmblkdst8		;; 8 iterations
	end_timer 22

	start_timer 23
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos pointer
	yloop	8, b3b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD2 + 16*clm*YMM_SCD4 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b5b, -16*2*clmblkdst8, rdi, -4*4*clm*64 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 8*clm+4*clm cache lines of s/c data.
;; A grand total of 15360 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD2		;; First sin/cos ptr

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-16*clm*YMM_SCD4]	;; Second premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	mov	edx, 4*clmblkdst		;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 64*4*clm			;; 64 iters of 4*clm

b7a:	start_timer 25
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 120, (64+64)
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, rdx
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 120, (64+64)
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rbx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	edx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a, 0, rbx, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b7a				;; Test loop counter

ELSE

	start_timer 25
	yloop_init 64*4*clm			;; 64 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	32, b7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -16*clm*YMM_SCD4		;; Next premult/sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 64*4*clm			;; 64 iters of 4*clm
pfing	bump	rcx, (120-64-64)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yr4_sg4cl_four_complex_fft4_preload
b9b:	yr4_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b, 0, rdi, clm*YMM_SCD4	;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b9b				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 2048 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM

ENDIF



;;; ******************************** Newer versions that reduce s/c data at the cost of more complex muls *********************************


IFDEF YIMPL_REDUCED_SINCOS_FFTS

;; Perform a pass 1 FFT of length 128 doubles.
;; Memory examples are for a 128K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 3*clm*YMM_SCD1 = 27*clm 64-byte cache lines

yr4dwpn_pass1sc128 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7b, b8b, b9a, b9aa, b9b, c0b, c1b, c6b, c7b, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 128, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 128K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 15 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 3.75 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9a, -2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 12 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 3 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c7b, -2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 16
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 16

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 8*4*blkdst		;; We've already prefetched 8 blocks
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 12 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 3 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 3*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_init 4*4*clm			;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7b,	-2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 15 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 3.75 macros each processing 32 data values

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YDOUBLE		;; Prefetch 30*clm cache lines
	yloop_set_alternate_prefetch_increment 27, 30
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b9a				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 128 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 128 doubles.
;; Memory examples are for a 128K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 4*clm*YMM_SCD1 = 18*clm 64-byte cache lines

yr4dwpn_pass1sc128ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b7b, b9a, b9b, c0b, c1b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 128, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 128K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 16 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9a, -2*clmblkdst8		;; Loop, restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c7b,	-2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...

;; Do 16 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 4*4*clm			;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 16
	jmp	endlp				;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 16

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 four_complex_first_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 8*4*blkdst			;; We've already prefetched 8 blocks
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst		;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 16 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 4*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 16 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 32 data values

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_prefetch YSINGLE		;; Prefetch 16*clm cache lines
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b9a				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 128 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 256 doubles.
;; Memory examples are for a 256K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 7*clm*YMM_SCD1 = 31*clm 64-byte cache lines

yr4dwpn_pass1sc256 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7b, b8b, b9a, b9aa, b9b, c0b, c1b, c6b, c7b, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 256, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 256K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 31 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_init 8*4*clm			;; 8*4*clm iterations
	yloop_set_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	4, c9a, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 28 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 7 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 8*4*clm			;; 8*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	4, c7b, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...

;; Do 32 sixteen_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 4 macros each processing 64 data values

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm			;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 8 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 32
	jmp	endlp				;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 32

;; Do FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 sixteen_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 64 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 16*4*blkdst		;; We've already prefetched 16 blocks
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 8 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iters prefetching 8*clm cache lines
	yloop	4, b1b, -4*clmblkdst		;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 28 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 7 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 7*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_init 8*4*clm			;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, b7b,	-4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 31 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 32 data values

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 8*4*clm			;; 8 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YSINGLE		;; Prefetch 31*clm cache lines
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, b9a				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 256 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 256 doubles.
;; Memory examples are for a 256K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD2 + clm*YMM_SCD4 + 4*clm*YMM_SCD1 = 32*clm 64-byte cache lines

yr4dwpn_pass1sc256ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b7b, b9a, b9b, c0b, c1b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 256, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 256K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 16 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 64 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_prefetch YNONE		;; Prefetch no blocks
c9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	4, c9a, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 8*4*clm			;; 8*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, restore sin/cos pointers
	yloop	4, c7b,	-4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...

;; Do 32 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 8 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 32
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 32

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 four_complex_first_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 16*4*blkdst	;; We've already prefetched 16 blocks
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 8 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst	;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 32 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 4*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_init 8*4*clm			;; 8 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, restore sin/cos ptrs
	yloop	4, b7b, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 16 eight_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 64 data values

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YDOUBLE		;; Prefetch 32*clm cache lines
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, b9a				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 256 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 320 doubles.
;; Memory examples are for a 320K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 9*clm*YMM_SCD1 = 33*clm 64-byte cache lines

;; This pass processes 160*clm cache lines, or 40KB if clm=4, suggesting we should use clm=4:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc320 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 320, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 320K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 39 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 36 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 9 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (40*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 10*4*clm			;; 10*4*clm iterations
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+9*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 9 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	5, c9a, -5*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 10*4*clm			;; 10*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	5, c9a, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 10*4*clm			;; 10*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 9 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	5, c7b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...

;; Do 16 twenty_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 80 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 40
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 40

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 80 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, (27-3)*4*blkdst	;; We've already prefetched 27 blocks which will be 3 too many
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	4, b1b, -4*clmblkdst ;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 36 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 9 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 39 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (40*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+9*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 10*4*clm			;; 10 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 18*clm cache lines
	yloop_set_alternate_prefetch_increment 33, (18+20)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Loop, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YHALF		;; Prefetch 20*clm cache lines
	yloop_set_alternate_prefetch_increment 33, (18+20)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 9*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 10*4*clm			;; 10 iterations of 4*clm
	yloop_set_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 18*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b7b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 10*4*clm			;; 10 iters of 4*clm
pfing	bump	rcx, (33-18-20)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YHALF		;; Prefetch 20*clm cache lines
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 320 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 384 doubles.
;; Memory examples are for a 384K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 11*clm*YMM_SCD1 = 35*clm 64-byte cache lines

;; This pass processes 192*clm cache lines, or 48KB if clm=4, suggesting we should use clm=4:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc384 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 384, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 384K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 47 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 44 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 11 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 12*4*clm			;; 12*4*clm iterations
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+11*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, c9a, -6*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	6, c9a, -6*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, c7b, -6*clmblkdst8		;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...

;; Do 16 twenty_four_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 96 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 48
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 48

;; Do FFT levels 1,2,3,4,5 (actually 4.565 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_four_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 96 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 32*4*blkdst		;; We've already prefetched 32 blocks
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst		;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 44 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 11 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 47 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+11*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 12*4*clm			;; 12 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 2*clm cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 22*clm cache lines
	yloop_set_alternate_prefetch_increment 35, (2+22+12)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 12*clm cache lines
	yloop_set_alternate_prefetch_increment 35, (2+22+12)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 11*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iterations of 4*clm
	yloop_set_prefetch YHALF		;; Prefetch 2*clm cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 22*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, restore source pointer
	yloop	6, b7b, -6*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
pfing	bump	rcx, (35-2-22-12)*clm*64	;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 12*clm cache lines
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	6, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 384 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 384 doubles.
;; Memory examples are for a 384K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 12*clm*YMM_SCD1 = 26*clm 64-byte cache lines

;; This pass processes 192*clm cache lines, or 48KB if clm=4, suggesting we should use clm=4:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc384ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 384, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 384K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 48 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 12 macros each processing 32 data values

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD2		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+12*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 12*4*clm			;; 12*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	12, c9a, -12*4*clmblkdst	;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	12, c9a, -4*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	12, c7b, -12*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 64 three_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 24 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...

;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 48K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+18 cache lines of s/c data.
;; A grand total of 16000 bytes with clm=4 -- easily fits in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16 or 12 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+12*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+12*clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*12*clmblkdst, rdi, YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -3*4*clmblkdst+clmblkdst, rbp, -3*4*YMM_SCD6+YMM_SCD6 ;; Loop 3 times!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter, restore source pointer

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+12*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD1 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, c5b, -4*clmblkdst+12*clmblkdst, rdi, -4*YMM_SCD1 ;; 4 iterations, restore sin/cos ptr
	yloop	4, c5b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 12*4*clm			;; 12 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	12, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 48
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 48

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 48 four_complex_first_fft operations
;;	distance between fft data elements is 48K
;;	do 12 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 three_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 18+4 cache lines of s/c data.
;; A grand total of 16000 bytes with clm=4 -- easily fits in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 28*4*blkdst		;; We've already prefetched 28 blocks

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+12*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 16*4*clm			;; 12 or 16 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -3*4*clmblkdst, rdi, -3*4*YMM_SCD6+YMM_SCD6 ;; 3 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rbp, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+12*clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*12*clmblkdst+clmblkdst, rbp, YMM_SCD1 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	12, b1b, -12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD1 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+12*clmblkdst, rdi, -4*YMM_SCD1 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 12 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+4*clm*64+clm*YMM_SCD2+12*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 12*clm cache lines
	yloop_set_alternate_prefetch_increment 26, (12+24)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
	yloop_set_alternate_prefetch_increment 26, (12+24)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	12, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 12*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 12*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
pfing	bump	rcx, (26-12-24)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	yloop	12, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 384 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 448 doubles.
;; Memory examples are for a 448K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 14*clm*YMM_SCD1 = 37*clm 64-byte cache lines

;; This pass processes 224*clm cache lines, or 56KB if clm=4, suggesting we should use clm=4:  56KB of scratch area, 56KB of input FFT data,
;; 56KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc448 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 448, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 448K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 55 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 52 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 13 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (56*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 14*4*clm			;; 14*4*clm iterations
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+13*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 14 blocks
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 13 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	7, c9a, -7*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 14*4*clm			;; 14*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 14 blocks
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	7, c9a, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 14*4*clm			;; 14*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 13 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	7, c7b, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	224K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	220K	...

;; Do 16 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 112 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 56
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 56

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	224K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	220K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 112 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, (43-3)*4*blkdst	;; We've already prefetched 43 blocks which will be 3 too many
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 52 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 13 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 55 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (56*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+13*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 14*4*clm			;; 14 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 26*clm cache lines
	yloop_set_alternate_prefetch_increment 37, (26+14)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 14*clm cache lines
	yloop_set_alternate_prefetch_increment 37, (26+14)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	7, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 13*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 14*4*clm			;; 14 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 26*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	7, b7b, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 14*4*clm			;; 14 iters of 4*clm
pfing	bump	rcx, (37-26-14)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 14*clm cache lines
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	7, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 448 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 512 doubles.
;; Memory examples are for a 512K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 15*clm*YMM_SCD1 = 39*clm 64-byte cache lines

;; This pass processes 256*clm cache lines, or 64KB if clm=4, suggesting we should use clm=4:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

IFDEF SLOWER_BUT_USES_LESS_MEMORY
yr4dwpn_pass1sc512 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 512, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 512K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 63 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 60 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 15 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16*4*clm iterations
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+15*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	8, c7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...

;; Do 64 eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+12 cache lines of s/c data.
;; A grand total of 19200 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rdi+16*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+2*clmblkdst8 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+2*clmblkdst8 ;; Test loop counter
	yloop	4, c5b, -4*2*clmblkdst8, rbx, YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 18
	loops_undo 4*4*clm

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD3 ;; Test loop counter
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c1b, -2*clmblkdst8+clmblkdst, rdi, -4*4*YMM_SCD3+YMM_SCD3 ;; 2 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 16*YMM_SCD3		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations

	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sine/cosine pointer
	yloop	4, c5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -16*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 64
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 64

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 12+4 cache lines of s/c data.
;; A grand total of 19200 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 40*4*blkdst		;; We've already prefetched 40 blocks

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+16*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, b1b, -2*clmblkdst8, rdi, -4*4*YMM_SCD3+YMM_SCD3 ;; 2 iterations, restore source pointer, next sin/cos ptr
	loops_undo 2*2*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b4b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YHALF
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*2*clmblkdst8+clmblkdst, rbx, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3	;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 60 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 15 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 63 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+15*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YHALF		;; Prefetch 30*clm cache lines
	yloop_set_alternate_prefetch_increment 39, (30+15)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 15*clm cache lines
	yloop_set_alternate_prefetch_increment 39, (30+15)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 15*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 30*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (39-30-15)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 15*clm cache lines
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 512 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF


;; Perform a pass 1 FFT of length 512 doubles.
;; Memory examples are for a 512K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 7*clm*YMM_SCD1 = 55*clm 64-byte cache lines
;;
;; This pass processes 256*clm cache lines, or 64KB if clm=4, suggesting we should use clm=4:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc512 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 512, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 512K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 7,8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 31 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 64 data values

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 56 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 14 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 8*4*clm or 16*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+7*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 16 blocks
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 8*4*clm			;; 8*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 16 blocks
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	8, c7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...

;; Do 32 sixteen_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 64 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 64
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 64

;; Do FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 sixteen_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 64 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 48*4*blkdst	;; We've already prefetched 48 blocks
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst	;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 56 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 14 macros each processing 32 data values

;; Do FFT levels 7,8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 31 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+7*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 or 8 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 28*clm cache lines
	yloop_set_alternate_prefetch_increment 55, (28+31)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 31*clm cache lines
	yloop_set_alternate_prefetch_increment 55, (28+31)
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	16, b7a				;; 8 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 7*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 28*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	8, b7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 8*4*clm			;; 8 iters of 4*clm
pfing	bump	rcx, (55-28-31)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YSINGLE		;; Prefetch 31 cache lines
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 512 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 512 doubles.
;; Memory examples are for a 512K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 = 30*clm 64-byte cache lines

;; This pass processes 256*clm cache lines, or 64KB if clm=4, suggesting we should use clm=4:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc512ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 512, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 512K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 64 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD2		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+16*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	8, c7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+16*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations
	yloop	4, c5b, -4*2*clmblkdst8, rdi, YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, c1b, -2*clmblkdst8+clmblkdst, rbp, -4*4*YMM_SCD6+YMM_SCD6 ;; 2 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+16*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 64
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 64

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 four_complex_first_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 24+8*clm cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 40*4*blkdst		;; We've already prefetched 40 blocks

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+16*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 16*4*clm			;; 16 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, b1b, -2*clmblkdst8, rdi, -4*4*YMM_SCD6+YMM_SCD6 ;; 2 iterations, restore source ptr, next sin/cos ptr
	loops_undo 2*2*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*2*clmblkdst8+clmblkdst, rbp, YMM_SCD2 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations
	end_timer 22

	start_timer 24
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 16 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+4*clm*64+clm*YMM_SCD2+16*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
	yloop_set_alternate_prefetch_increment 30, (16+16)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
	yloop_set_alternate_prefetch_increment 30, (16+16)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (30-16-16)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 512 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 640 doubles.
;; Memory examples are for a 640K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 9*clm*YMM_SCD1 = 57*clm 64-byte cache lines
;;
;; This pass processes 320*clm cache lines, or 80KB if clm=4, suggesting we should use clm=4:  80KB of scratch area, 80KB of input FFT data,
;; 80KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc640 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 640, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 640K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 39 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 72 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 20*4*clm			;; 10*4*clm or 20*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+9*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	10, c9a, -10*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 10*4*clm			;; 10*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	10, c9a, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	10, c7b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K	...

;; Do 32 twenty_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 80 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 80
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 80

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 80 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, 46*4*blkdst	;; We've already prefetched 46 blocks which will be 2 too few!
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst	;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 72 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 39 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+9*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 or 10 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 18*clm cache lines
	yloop_set_alternate_prefetch_increment 57, (18+39)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 39*clm cache lines
	yloop_set_alternate_prefetch_increment 57, (18+39)
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	20, b7a				;; 10 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 9*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 18*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	10, b7b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 10*4*clm			;; 10 iters of 4*clm
pfing	bump	rcx, (57-18-39)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YSINGLE		;; Prefetch 39 cache lines
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	10, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 640 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 640 doubles.
;; Memory examples are for a 640K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 20*clm*YMM_SCD1 = 34*clm 64-byte cache lines

;; This pass processes 320*clm cache lines, or 80KB if clm=4, suggesting we should use clm=4:  80KB of scratch area, 80KB of input FFT data,
;; 80KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc640ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 640, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 640K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 80 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 80 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD2		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+20*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 20*4*clm			;; 20*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	20, c9a, -20*4*clmblkdst	;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 20*4*clm			;; 20*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	20, c9b, -4*20*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	20, c7b, -20*4*clmblkdst, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...

;; Do 64 five_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 40 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K	...

;; Do 80 four_complex_unfft operations
;;	distance between fft data elements is 80K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 16 or 20 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+20*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+20*clmblkdst ;; 4*clm iterations
	yloop	8, c5b, -4*20*clmblkdst, rdi, YMM_SCD2 ;; 4 iterations!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -5*4*clmblkdst+clmblkdst, rbp, -5*4*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+20*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, c5b, -4*clmblkdst+20*clmblkdst, rdi, -4*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	20, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 80
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 80

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...

;; Do 80 four_complex_first_fft operations
;;	distance between fft data elements is 80K
;;	do 20 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 five_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 40 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 30+8*clm cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 44*4*blkdst		;; We've already prefetched 44 blocks

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+20*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 32*4*clm			;; 20 or 16 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -5*4*clmblkdst, rdi, -5*4*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, 4*clmblkdst, rbp, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+20*clmblkdst ;; 4*clm iterations
	yloop	8, b5b, -4*20*clmblkdst+clmblkdst, rbp, YMM_SCD2 ;; 4 iterations!! next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	20, b1b, -20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+20*clmblkdst, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 80 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 20 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 80 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+4*clm*64+clm*YMM_SCD2+20*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
	yloop_set_alternate_prefetch_increment 34, (20+20)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer. restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
	yloop_set_alternate_prefetch_increment 34, (20+20)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	20, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 20*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	20, b7b, -20*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
pfing	bump	rcx, (34-20-20)*clm*64		;; Finish prefetching the sin/cos/premult data
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	yloop	20, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 640 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 768 doubles.
;; Memory examples are for a 768K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 11*clm*YMM_SCD1 = 59*clm 64-byte cache lines

;; This pass processes 384*clm cache lines, or 96KB if clm=4, suggesting we should use clm=2:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc768 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 768, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 768K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 47 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 88 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 22 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 24*4*clm			;; 12*4*clm or 24*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+11*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 24 blocks
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	12, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 24 blocks
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	12, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 24*4*clm			;; 24*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	12, c7b, -12*clmblkdst8, rdi, 2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...

;; Do 32 twenty_four_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 96 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 96
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 96

;; Do FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_four_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 96 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 64*4*blkdst		;; We've already prefetched 64 blocks
	yloop_init 8*4*clm			;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD		;; Prefetch 32 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst		;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 72 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 47 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+11*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 or 12 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 22*clm cache lines
	yloop_set_alternate_prefetch_increment 59, (22+47)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
	yloop_set_alternate_prefetch_increment 59, (22+47)
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	24, b7a				;; 12 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 11*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 22*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
pfing	bump	rcx, (59-22-47)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	12, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 768 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 768 doubles.
;; Memory examples are for a 768K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD2 + clm*YMM_SCD4 + 12*clm*YMM_SCD1 = 40*clm 64-byte cache lines

;; This pass processes 384*clm cache lines, or 96KB if clm=4, suggesting we should use clm=2:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This ought to fit in 256KB L2 cache.

yr4dwpn_pass1sc768ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 768, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 768K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 48 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines of input FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- marginally fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD4		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+12*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 24*4*clm			;; 12*4*clm or 24*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	12, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	12, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 24*4*clm			;; 24*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	12, c7b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...

;; Do 128 three_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 24 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...

;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 96K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+100% prefetching next scratch area section) + 4*clm+24 cache lines of s/c data.
;; A grand total of 27136 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 32 or 24 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+24*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c5b, -4*clm*64+3*clmblkdst8 ;; 4*clm iterations
	yloop	4, c5b, -4*3*clmblkdst8, rdi, YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -3*clmblkdst8+clmblkdst, rbp, -3*8*YMM_SCD6+YMM_SCD6 ;; Loop 3 times!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+24*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD1 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, c5b, -8*clmblkdst+3*clmblkdst8, rdi, -8*YMM_SCD1 ;; 8 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 24*4*clm			;; 24 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8	;; Test loop counter
	yloop	3, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 96
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 96

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...

;; Do 96 four_complex_first_fft operations
;;	distance between fft data elements is 96K
;;	do 24 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 three_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+100% prefetching next scratch area section) + 24+4*clm cache lines of s/c data.
;; A grand total of 27136 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 64*4*blkdst		;; We've already prefetched 64 blocks

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+24*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 32*4*clm			;; 24 or 32 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -3*clmblkdst8, rdi, -3*8*YMM_SCD6+YMM_SCD6 ;; 3 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+3*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*3*clmblkdst8+clmblkdst, rbp, YMM_SCD1 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 24*4*clm			;; 24 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	3, b1b, -3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD1 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b5b, -8*clmblkdst+3*clmblkdst8, rdi, -8*YMM_SCD1 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 96 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 24 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 48 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+2*4*clm*64+clm*YMM_SCD4+12*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 or 12 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 24*clm cache lines
	yloop_set_alternate_prefetch_increment 40, (24+24)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
	yloop_set_alternate_prefetch_increment 40, (24+24)
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	24, b7a				;; 12 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 12*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 24*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 12*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (40-24-24)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	12, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 768 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 896 doubles.
;; Memory examples are for a 896K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 13*clm*YMM_SCD1 = 61*clm 64-byte cache lines

;; This pass processes 448*clm cache lines, or 112KB if clm=4, suggesting we should use clm=2:  56KB of scratch area, 56KB of input FFT data,
;; 56KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc896 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b, c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 896, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 896K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 55 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 104 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 26 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (112*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 28*4*clm			;; 14*4*clm or 28*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+13*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 28 blocks
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 26 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	14, c9a, -14*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 14*4*clm			;; 14*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 28 blocks
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	14, c9a, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 28*4*clm			;; 28*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 26 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	14, c7b, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	448K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	444K	...

;; Do 32 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 112 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 112
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 112

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	448K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	444K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_eight_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 112 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	bump	rcx, (86-6)*4*blkdst	;; We've already prefetched 86 blocks which will be 6 too many
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 104 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 26 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 55 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (112*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+13*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 28*4*clm			;; 28 or 14 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 52*clm cache lines
	yloop_set_alternate_prefetch_increment 61, (52+28)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YHALF		;; Prefetch 28*clm cache lines
	yloop_set_alternate_prefetch_increment 61, (52+28)
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	28, b7a				;; 14 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 13*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 28*4*clm			;; 28 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 52*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	14, b7b, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 14*4*clm			;; 14 iters of 4*clm
pfing	bump	rcx, (61-52-28)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YHALF		;; Prefetch 28*clm cache lines
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	14, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 896 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1024 doubles.
;; Memory examples are for a 1024K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 15*clm*YMM_SCD1 = 63*clm 64-byte cache lines

;; This pass processes 512*clm cache lines, or 128KB if clm=4, suggesting we should use clm=2:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc1024 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1024, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1024K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 63 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 120 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 30 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 16*4*clm or 32*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+15*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	16, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	16, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	16, c7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macro processing 32 data values
;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...

;; Do 128 eight_reals_unfft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+12 cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rdi+32*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+4*clmblkdst8 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+4*clmblkdst8 ;; Test loop counter
	yloop	4, c5b, -4*4*clmblkdst8, rbx, YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 18
	loops_undo 4*4*clm

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD3 ;; Test loop counter
	yloop	4, c1b, -4*clmblkdst8+clmblkdst, rdi, -4*8*YMM_SCD3+YMM_SCD3 ;; 4 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 32*YMM_SCD3		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, c4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; 8 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -32*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 128
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 128

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 eight_reals_fft operations
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values
;; Do 96 four_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 12+4 cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 80*4*blkdst		;; We've already prefetched 80 blocks

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+32*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD3 ;; 4*clm iters, next source ptr, next sin/cos ptr
	yloop	4, b1b, -4*clmblkdst8, rdi, -4*8*YMM_SCD3+YMM_SCD3 ;; 4 iterations, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b4b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*4*clmblkdst8+clmblkdst, rbx, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3	;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, b1b, -4*clmblkdst8		;; 4 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 120 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 30 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 63 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+15*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 or 16 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yloop_set_alternate_prefetch_increment 63, (0+63)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
	yloop_set_alternate_prefetch_increment 63, (0+63)
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	32, b7a				;; 16 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 15*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (63-0-63)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	16, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1024 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 1024 doubles.
;; Memory examples are for a 1024K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD2 + clm*YMM_SCD4 + 16*clm*YMM_SCD1 = 44*clm 64-byte cache lines

;; This pass processes 512*clm cache lines, or 128KB if clm=4, suggesting we should use clm=2:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc1024ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 1024, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1024K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 64 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines of input FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- marginally fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD4		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+16*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 32*4*clm			;; 16*4*clm or 32*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	16, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	16, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	16, c7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 32*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+32*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations
	yloop	4, c5b, -4*4*clmblkdst8, rdi, YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -4*clmblkdst8+clmblkdst, rbp, -4*8*YMM_SCD6+YMM_SCD6 ;; 4 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+32*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, c5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD2 ;; 8 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 128
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 128

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 four_complex_first_fft operations
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 four_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 80*4*blkdst		;; We've already prefetched 80 blocks

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+32*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 32*4*clm			;; 32 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst8, rdi, -4*8*YMM_SCD6+YMM_SCD6 ;; 4 iterations, restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*4*clmblkdst8+clmblkdst, rbp, YMM_SCD2 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, b1b, -4*clmblkdst8		;; 4 iterations
	end_timer 22

	start_timer 24
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 128 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 64 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+2*4*clm*64+clm*YMM_SCD4+16*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 or 16 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 32*clm cache lines
	yloop_set_alternate_prefetch_increment 44, (32+16)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
	yloop_set_alternate_prefetch_increment 44, (32+16)
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	32, b7a				;; 16 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 16*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 32*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (44-32-16)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	16, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1024 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1280 doubles.
;; Memory examples are for a 1280K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 39*clm*YMM_SCD1 = 63*clm 64-byte cache lines

;; This pass processes 640*clm cache lines, or 160KB if clm=4, suggesting we should use clm=1:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1280 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1280, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1280K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 159 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 39.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 156 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 39 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 40*4*clm			;; 40*4*clm iterations
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+39*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	20, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 40*4*clm			;; 40*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	20, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	20, c7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 144 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 36 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K	...

;; Do 64 twenty_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 80 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 160 cache lines of data (+1/10 due to ineffective L1 prefetching) + 4+36 cache lines of s/c data.
;; A grand total of 12800 bytes -- should fit in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rdi, [rbp+16*YMM_SCD9]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 40*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 6*4			;; Do 40 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8	;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -10*2*clmblkdst8	;; 10 iterations!!  Restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 6*2*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD9 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD9 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD9, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 16*YMM_SCD9		;; Sin/cos ptr
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	10, c5b, -10*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -16*YMM_SCD9		;; Next fixed sine/cosine pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 160
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 160

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 80 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 144 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 36 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 160 cache lines of data (+1/4 due to ineffective L1 prefetching) + 36+4 cache lines of s/c data.
;; A grand total of 12800 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 92*4*blkdst		;; We've already prefetched 92 blocks

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rdi, [rbp+16*YMM_SCD9]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 16 or 40 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr5_10cl_20_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD9 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD9 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 6*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	16, b5b, -10*2*clmblkdst8+4*64	;; 10 iterations!!  Next source pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD9, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; Test loop counter, next source ptr, next sin/cos ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4	;; Test loop counter, next source pointer, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	10, b5b, -10*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 156 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 39 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 159 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 39.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+39*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 40*4*clm			;; 40 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 39*clm cache lines
	yloop_set_alternate_prefetch_increment 63, (39+40)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 40*clm cache lines
	yloop_set_alternate_prefetch_increment 63, (39+40)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	20, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 39*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 39*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	20, b7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 40*4*clm			;; 40 iters of 4*clm
pfing	bump	rcx, (63-39-40)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 40*clm cache lines
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	20, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1280 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 1280 doubles.
;; Memory examples are for a 1280K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD2 + clm*YMM_SCD4 + 20*clm*YMM_SCD1 = 48*clm 64-byte cache lines

;; This pass processes 640*clm cache lines, or 160KB if clm=4, suggesting we should use clm=1:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1280ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 1280, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1280K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 80 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 160 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD4		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+20*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 40*4*clm			;; 20*4*clm or 40*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	20, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	20, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	20, c7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...

;; Do 128 five_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 40 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K	...

;; Do 160 four_complex_unfft operations
;;	distance between fft data elements is 160K
;;	do 40 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 32 or 40 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+40*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+5*clmblkdst8 ;; 4*clm iterations
	yloop	8, c5b, -4*5*clmblkdst8, rdi, YMM_SCD2 ;; 4 iterations!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -5*clmblkdst8+clmblkdst, rbp, -5*8*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+40*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, c5b, -8*clmblkdst+5*clmblkdst8, rdi, -8*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	5, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 160
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 160

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...

;; Do 160 four_complex_first_fft operations
;;	distance between fft data elements is 160K
;;	do 40 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 five_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 40 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 88*4*blkdst		;; We've already prefetched 88 blocks

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+40*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 64*4*clm			;; 40 or 32 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch a short distance ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters
	yloop	8, b1b, -5*clmblkdst8, rdi, -5*8*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+5*clmblkdst8 ;; 4*clm iterations
	yloop	8, b5b, -4*5*clmblkdst8+clmblkdst, rbp, YMM_SCD2 ;; 4 iterations!! next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 40*4*clm			;; 40 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	5, b1b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b5b, -8*clmblkdst+5*clmblkdst8, rdi, -8*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 160 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 80 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+2*4*clm*64+clm*YMM_SCD4+20*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 or 20 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 40*clm cache lines
	yloop_set_alternate_prefetch_increment 48, (40+20)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
	yloop_set_alternate_prefetch_increment 48, (40+20)
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	40, b7a				;; 20 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 20*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 40*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	20, b7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
pfing	bump	rcx, (48-40-20)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	20, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1280 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1536 doubles.
;; Memory examples are for a 1536K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 47*clm*YMM_SCD1 = 71*clm 64-byte cache lines

;; This pass processes 768*clm cache lines, or 192KB if clm=4, suggesting we should use clm=1:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1536 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1536, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1536K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 191 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 47.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 188 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 47 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 48*4*clm			;; 48*4*clm iterations
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+47*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	24, c9a, -24*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 48*4*clm			;; 48*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	24, c9a, -24*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	24, c7b, -24*clmblkdst8		;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 176 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 44 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...

;; Do 64 twenty_four_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 96 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/12 due to ineffective L1 prefetching) + 24+44 cache lines of s/c data.
;; A grand total of 17664 bytes -- should fit in a 32KB L1 cache.

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rdi, [rbp+16*YMM_SCD11]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 48*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 4*4			;; Do 48 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	16, c5b, -12*2*clmblkdst8	;; 12 iterations!!  Restore source pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 6*2*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD11 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD11 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD11, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 16*YMM_SCD11		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	12, c5b, -12*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -16*YMM_SCD11		;; Next fixed sine/cosine pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 192
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 192

;; Do FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_four_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 96 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 176 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 44 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/4 due to ineffective L1 prefetching) + 44+24 cache lines of s/c data.
;; A grand total of 19712 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 128*4*blkdst		;; We've already prefetched 128 blocks

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rdi, [rbp+16*YMM_SCD11]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 16 or 48 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr6_12cl_24_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD11 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD11 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 4*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	16, b5b, -12*2*clmblkdst8+4*64	;; 12 iterations!!  Next source pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD11, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; Test loop counter, next source ptr, next sin/cos ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4	;; Test loop counter, next source pointer, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	12, b5b, -12*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 188 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 47 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 191 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 47.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+47*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 48*4*clm			;; 48 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 47*clm cache lines
	yloop_set_alternate_prefetch_increment 71, (47+48)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 71, (47+48)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	24, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 47*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 47*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	24, b7b, -24*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm
pfing	bump	rcx, (71-47-48)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	24, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1536 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 1536 doubles.
;; Memory examples are for a 1536K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD1 + 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 = 46*clm 64-byte cache lines

;; This pass processes 768*clm cache lines, or 192KB if clm=4, suggesting we should use clm=1:  48KB of scratch area,
;; 48KB of input FFT data, 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1536ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b3a, b3b, b5b, b7aa, b7a, b7b, b9b
	LOCAL	c0b, c1b, c3a, c3b, c5a, c5b, c7b, c9aa, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 1536, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1536K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 192 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	bump	rdi, clm*YMM_SCD2		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+16*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 48*4*clm			;; 48*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	end_timer 16
c9aa:	start_timer 16
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	3, c9aa				;; Test loop counter
	yloop	16, c9a, -48*4*clmblkdst	;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 48*4*clm			;; 48*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	12, c9b				;; Test loop counter, next premult/sin/cos pointer
	yloop	16, c9a, -192*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	48, c7b, -48*4*clmblkdst, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 256 three_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 24 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 48K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 192K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/16 due to ineffective L1 prefetching) + 4+6+72 cache lines of s/c data.
;; A grand total of 18304 bytes -- easily fitting in a 32KB L1 cache.

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 64*4*clm or 48*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+48*YMM_SCD6]		;; Second sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4, L1PREFETCH_ALL, 12*clmblkdst ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD1 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*12*clmblkdst, rdi, 4*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 16*4
	end_timer 18

	start_timer 19
c3a:	yloop_adjust 4				;; Fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	4, c3b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD2 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer
	yloop	4, c3a, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_adjust 4*4			;; Fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4 iterations, next sin/cos ptr
	yloop	16, c1b, -12*4*clmblkdst+4*64, rbp, -12*4*YMM_SCD6 ;; 12 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c5a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos pointer
	yloop	16, c5b, -16*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	bump	rdi, 48*YMM_SCD6		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos data
	yloop	12, c3b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD2 ;; 2 iterations, restore sin/cos pointer
	yloop	4, c3b, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -48*YMM_SCD6		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	48, c1b				;; 48 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 192
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 192

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...

;; Do 192 four_complex_first_fft operations
;;	distance between fft data elements is 192K
;;	do 48 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 48K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	48K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 three_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/12 due to ineffective L1 prefetching) + 4+6+72 cache lines of s/c data.
;; A grand total of 18560 bytes -- easily fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 144*4*blkdst		;; We've already prefetched 144 blocks

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+48*YMM_SCD6]		;; Second sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1
	yloop_init 64*4*clm			;; 48 or 64 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 4*4			;; Fewer iterations this loop
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rbp, 0, 4, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; Test loop counter, next sin/cos ptr
	yloop	16, b1b, -12*4*clmblkdst, rbp, -12*4*YMM_SCD6 ;; 12 iterations!!  Restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
b3a:	yloop_adjust 4				;; Fewer iterations this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	4, b3b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD2 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer
	yloop	4, b3a, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4
	yloop	4, b5b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD1 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*12*clmblkdst+4*64, rdi, 4*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, b1a, -4*clmblkdst, rdi, -4*clm*4*YMM_SCD1 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	48, b1b, -48*clmblkdst		;; 48 iterations
	end_timer 22

	start_timer 23
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos pointer
	yloop	12, b3b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b3b, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	16, b5b, -16*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD2		;; First sin/cos ptr (for timer 25)

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-4*clm*64-16*clm*YMM_SCD1] ;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm

b7aa:	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	end_timer 26

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 46, 48 ;; Prefetch 46*clm instead
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	3, b7a				;; Test loop counter
	yloop	16, b7aa			;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	48, b7b, -48*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*64-16*clm*YMM_SCD1	;; Delayed sin/cos multipliers
	lea	rbx, [rdi-clm*YMM_SCD2]		;; Complex data sin/cos ptr (a.k.a. PREMULT_ADDR)
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 46, 48 ;; Prefetch 46*clm instead
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	12, b9b				;; Test loop counter
	yloop	16, b9a				;; Test loop counter

ENDIF

;; Work on next 4*clm sets of 1536 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 1792 doubles.
;; Memory examples are for a 1792K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 55*clm*YMM_SCD1 = 79*clm 64-byte cache lines

;; This pass processes 896*clm cache lines, or 224KB if clm=4, suggesting we should use clm=1:  56KB of scratch area,
;; 56KB of input FFT data, 56KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1792 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 1792, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1792K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 223 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 55.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 220 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 55 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 56*4*clm			;; 56*4*clm iterations
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+55*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 56 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:
x64	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	28, c9a, -28*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 56*4*clm			;; 56*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	28, c9a, -28*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 56*4*clm			;; 56*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 56 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	28, c7b, -28*clmblkdst8		;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 208 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 52 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	896K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	892K	...

;; Do 64 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 112 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 224 cache lines of data (+1/14 due to ineffective L1 prefetching) + 24+52 cache lines of s/c data.
;; A grand total of 20224 bytes -- should fit in a 32KB L1 cache.

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rdi, [rbp+16*YMM_SCD13]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 56*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 2*4			;; Do 56 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	16, c5b, -14*2*clmblkdst8	;; 14 iterations!!  Restore source pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 6*2*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD13 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD13 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD13, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 16*YMM_SCD13		;; Sin/cos ptr
	yloop_init 56*4*clm			;; 56*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	14, c5b, -14*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -16*YMM_SCD13		;; Next fixed sine/cosine pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 224
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 224

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	896K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	892K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 112 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 208 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 52 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 224 cache lines of data (+1/4 due to ineffective L1 prefetching) + 52+24 cache lines of s/c data.
;; A grand total of 22784 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 140*4*blkdst		;; We've already prefetched 140 blocks

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rdi, [rbp+16*YMM_SCD13]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 16 or 56 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr7_14cl_28_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD13 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD13 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 2*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	16, b5b, -14*2*clmblkdst8+4*64	;; 14 iterations!!  Next source pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD13, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE 		;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 56*4*clm			;; 56 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; Test loop counter, next source ptr, next sin/cos ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4	;; Test loop counter, next source pointer, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	14, b5b, -14*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 220 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 55 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 223 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 55.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+55*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 56*4*clm			;; 56 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 55*clm cache lines
	yloop_set_alternate_prefetch_increment 79, (55+56)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:
x64	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 56*clm cache lines
	yloop_set_alternate_prefetch_increment 79, (55+56)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	28, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 55*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 56*4*clm			;; 56 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 55*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	28, b7b, -28*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 56*4*clm			;; 56 iters of 4*clm
pfing	bump	rcx, (79-55-56)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 56*clm cache lines
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	28, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1792 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 2048 doubles.
;; Memory examples are for a 2048K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 31*clm*YMM_SCD1 = 79*clm 64-byte cache lines

;; This pass processes 1024*clm cache lines, or 256KB if clm=4, suggesting we should use clm=1:  64KB of scratch area,
;; 64KB of input FFT data, 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

IFDEF SLOWER_BUT_LESS_SINCOS_MEMORY
	is it because of the 16 reals or is it because of the wpn4 at the lower level
	I suspect it is due to the moved wpn4 as sc512 also uses 16 reals though I don't see why the
		increase in group multipliers would cause a 4% slowdown
yr4dwpn_pass1sc2048 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 2048, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 2048K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 9,10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 127 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 31.75 macros each processing 64 data values

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 248 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 62 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 64*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+31*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	32, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 32*4*clm			;; 32*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	32, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	32, c7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macro processing 32 data values
;; Do 224 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 56 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...

;; Do 128 sixteen_reals_unfft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 128*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+12 cache lines of s/c data.
;; A grand total of 38+K bytes with clm=4 -- NOT fitting in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rdi+32*YMM_SCD7]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64 or 32 iters of 4*clm

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+4*clmblkdst8 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 32 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+4*clmblkdst8 ;; Test loop counter
	yloop	8, c5b, -8*4*clmblkdst8, rbx, YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD7 ;; Test loop counter
	yloop	8, c1b, -4*clmblkdst8+clmblkdst, rdi, -4*8*YMM_SCD7+YMM_SCD7 ;; 4 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 32*YMM_SCD7		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, c4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 32 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; 8 iterations, restore sin/cos pointer
	yloop	8, c5b, -8*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -32*YMM_SCD7		;; Next fixed sine/cosine pointer
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 256
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 256

;; Do FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 sixteen_reals_fft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 64 data values

;; Do FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values
;; Do 224 four_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 56 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 128*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 12+4 cache lines of s/c data.
;; A grand total of 38+K bytes with clm=4 -- NOT fitting in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 128*4*blkdst		;; We've already prefetched 128 blocks

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+32*YMM_SCD7]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 32 or 64 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 64 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD7 ;; 4*clm iters, next source ptr, next sin/cos ptr
	yloop	8, b1b, -4*clmblkdst8, rdi, -4*8*YMM_SCD7+YMM_SCD7 ;; 4 iterations!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b4b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations
	yloop	8, b5b, -8*4*clmblkdst8+clmblkdst, rbx, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 64 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7	;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, b1b, -4*clmblkdst8		;; 4 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	8, b5b, -8*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 248 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 62 macros each processing 32 data values

;; Do FFT levels 9,10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 127 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 31.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+31*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 64*4*clm			;; 64 or 32 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 62*clm cache lines
	yloop_set_alternate_prefetch_increment 79, (62+31)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 31*clm cache lines
	yloop_set_alternate_prefetch_increment 79, (62+31)
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	64, b7a				;; 32 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 31*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 62*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	32, b7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 32*4*clm			;; 32 iters of 4*clm
pfing	bump	rcx, (79-62-31)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 31*clm cache lines
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	32, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 2048 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF


;; Perform a pass 1 FFT of length 2048 doubles.
;; Memory examples are for a 2048K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*64 + 4*4*clm*YMM_SCD4 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 15*clm*YMM_SCD1 = 115*clm 64-byte cache lines

;; This pass processes 1024*clm cache lines, or 256KB if clm=4, suggesting we should use clm=1:  64KB of scratch area,
;; 64KB of input FFT data, 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc2048 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7aa, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 2048, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 2048K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 255 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 63.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 252 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 63 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 64*4*clm iterations
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+15*clm*YMM_SCD1]	;; Sin/cos ptr for timer 17
	end_timer 16
	jmp	c9aa

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	end_timer 16
c9aa:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 63 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:
x64	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9aa, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9aa				;; Test loop counter, next sin/cos pointer
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 64*4*clm			;; 64*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4cl_2sc_eight_reals_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9b				;; Test loop counter
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 63 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	32, c7b, -32*clmblkdst8, rdi, 4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 240 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 60 macros each processing 32 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 64 eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macro processing 32 data values
;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...

;; Do 256 eight_reals_unfft operations
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 due to ineffective L1 prefetching) + 24+16+48 cache lines of s/c data.
;; A grand total of 23040 bytes -- should fit in a 32KB L1 cache.

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rbp+64*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8, rdx, 4*32, rdi, 4*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 19
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c2b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c2b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, c2b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c2b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 24 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, c3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD3 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -8*clmblkdst8+4*64, rbp, -16*4*YMM_SCD3 ;; Test loop counter, next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbx, YMM_SCD4, rbp, YMM_SCD3 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 64*YMM_SCD3		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c2b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c2b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos pointer
	yloop	8, c2b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c2b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 24 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sine/cosine pointer
	yloop	8, c3b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; 2 iterations, restore sine/cosine pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -64*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, c1b				;; 8 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 256
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 256

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 eight_reals_fft operations
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values
;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 64K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 240 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 60 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 or +1/8 due to ineffective L1 prefetching) + 48+16+24 cache lines of s/c data.
;; A grand total of 23040 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, (151-3)*4*blkdst		;; We've already prefetched 151 blocks which will be 3 too many

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rbx, [rbp+64*YMM_SCD3]		;; Sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 15*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YNONE
	yr4_4cl_eight_reals_fft_preload
x64	mov	r9, 4*clmblkdst			;; A short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:
x64	yr4_4cl_eight_reals_fft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, r9 ;; Prefetch a short distance ahead
x32	yr4_4cl_eight_reals_fft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD3 ;; Test loop counter, next sin/cos ptr
x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b1b, -8*clmblkdst8, rbp, -16*4*YMM_SCD3 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b2b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b2b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, b2b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b2b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, b3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4
	yloop	4, b4b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 60 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*2*clmblkdst8+4*64, rdx, 4*32, rdi, 4*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointers
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD4, rbp, YMM_SCD3 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*64-4*clm*4*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, b1b, -8*clmblkdst8		;; 8 iterations, restore source pointer
	end_timer 22

	start_timer 23
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b2b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b2b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b2b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b2b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b3b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 15*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; Test loop counter, next source ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 60 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	16, b5b, -16*2*clmblkdst8, rdi, -4*4*clm*64 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 252 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 63 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 255 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 63.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD4		;; Premultiplier/sin/cos ptr

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 64*4*clm			;; 64 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr. restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7aa:	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	end_timer 26

b7a:	start_timer 25
	yloop_set_prefetch YQUARTER		;; Prefetch 63*clm cache lines
	yloop_set_alternate_prefetch_increment 115, (63+64)
	yr4_4cl_four_complex_djbfft_preload
b7b:
x64	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 115, (63+64)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a				;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b7aa			;; Test loop counter

ELSE

pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	start_timer 25
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 63*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	32, b7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4cl_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4cl_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdi, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
pfing	bump	rcx, (115-63-64)*clm*64		;; Finish prefetching the sin/cos/premult data
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 2048 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 negacyclic FFT of length 2048 doubles.
;; Memory examples are for a 2048K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*64 + 4*4*clm*YMM_SCD2 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 = 74*clm 64-byte cache lines

;; This pass processes 1024*clm cache lines, or 256KB if clm=4, suggesting we should use clm=1:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc2048ac MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b3b, b5b, b7a, b7aa, b7b, b9a, b9b, c0b, c1b, c3b, c5a, c5b, c7b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 1, 2048, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 2048K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 256 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+8*clm cache lines of s/c data.
;; A grand total of 15360 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	bump	rdi, clm*YMM_SCD2		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+16*clm*YMM_SCD1]	;; Sin/cos ptr for timer 17
	yloop_init 64*4*clm			;; 64*4*clm iterations
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	end_timer 16
c9aa:	start_timer 16
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:
x64	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
x32	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9aa, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9aa				;; Test loop counter
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 64*4*clm			;; 64*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9b				;; Test loop counter
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	32, c7b, -32*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 due to ineffective L1 prefetching) + 12+8+96 cache lines of s/c data.
;; A grand total of 24832 bytes -- should fit in a 32KB L1 cache.

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+64*YMM_SCD6]		;; Second sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations

c5a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8, rdx, 4*32, rdi, 4*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 16*4
	end_timer 18

	start_timer 19
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	2, c3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_set_clm_prefetch YNONE
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4 iterations, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -8*clmblkdst8+4*64, rbp, -16*4*YMM_SCD6 ;; Test loop counter, next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c5a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	16, c5b, -16*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	bump	rdi, 64*YMM_SCD6		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos data
	yloop	8, c3b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD2 ;; 2 iterations, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -64*YMM_SCD6		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, c1b				;; 8 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 256
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 256

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 four_complex_first_fft operations
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 or +1/8 due to ineffective L1 prefetching) + 96+8+12 cache lines of s/c data.
;; A grand total of 24832 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 128*4*blkdst		;; We've already prefetched 128 blocks

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+64*YMM_SCD6]		;; Second sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 ;; Third sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YNONE
x64	mov	r9, 4*clmblkdst			;; A short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:
x64	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, r9 ;; Prefetch a short distance ahead
x32	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; Test loop counter, next sin/cos ptr
x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b1b, -8*clmblkdst8, rbp, -16*4*YMM_SCD6 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	2, b3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*2*clmblkdst8+4*64, rdx, 4*32, rdi, 4*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptrs
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*64-4*clm*4*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, b1b, -8*clmblkdst8		;; 8 iterations
	end_timer 22

	start_timer 23
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos pointer
	yloop	8, b3b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b5b, -16*2*clmblkdst8, rdi, -4*4*clm*64 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 8*clm+4*clm cache lines of s/c data.
;; A grand total of 15360 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD2		;; First sin/cos ptr (for timer 25)

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-16*clm*YMM_SCD1]	;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 64*4*clm			;; 64 iters of 4*clm
x64	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

b7aa:	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	end_timer 26

b7a:	start_timer 25
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 74, (64+64)
	yr4_4cl_four_complex_djbfft_preload
b7b:
x64	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, r9
x32	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 74, (64+64)
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

x64	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a				;; Test loop counter
	yloop	16, b7aa			;; Test loop counter

ELSE

	start_timer 25
	yloop_init 64*4*clm			;; 64 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	32, b7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -16*clm*YMM_SCD1		;; Delayed sin/cos multipliers
	lea	rbx, [rdi-clm*YMM_SCD2]		;; Complex data sin/cos ptr (a.k.a. PREMULT_ADDR)
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 64*4*clm			;; 64 iters of 4*clm
pfing	bump	rcx, (74-64-64)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4cl_four_complex_fft4_preload
b9b:	yr4_rsc_sg4cl_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, 2*blkdst, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 4*blkdst
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b				;; Test loop counter
	yloop	16, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 2048 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM

ENDIF





;;; ******************************** This version allows pass1 code blocks to be shared *********************************


IFDEF YIMPL_SHARED_PASS1_CODE

;; Perform a shared pass 1 FFT of length 128 doubles.
;; Memory examples are for a 128K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 3*clm*YMM_SCD1 = 27*clm 64-byte cache lines

yr4dwpn_pass1sc128 MACRO
	LOCAL	b0b, b1b, b6b, b7b, b8b, b9a, b9aa, b9b, c0b, c1b, c6b, c7b, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 128K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 15 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 3.75 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9a, -2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 12 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 3 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c7b, -2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 16
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 16

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	mov	r8, pass2blkdst		;; blkdst
pfing	imul	rax, blkdstreg, 8*4	;; We've already prefetched 8 blocks
pfing	add	rcx, rax
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 4 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 12 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 3 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 3*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_init 4*4*clm			;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7b,	-2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 15 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 3.75 macros each processing 32 data values

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YDOUBLE		;; Prefetch 30*clm cache lines
	yloop_set_alternate_prefetch_increment 27, 30
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b9a				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 128 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 negacyclic FFT of length 128 doubles.
;; Memory examples are for a 128K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 4*clm*YMM_SCD1 = 18*clm 64-byte cache lines

yr4dwpn_pass1sc128ac MACRO
	LOCAL	b0b, b1b, b7b, b9a, b9b, c0b, c1b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 128K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 16 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9a, -2*clmblkdst8		;; Loop, restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c7b,	-2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...

;; Do 16 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 4*4*clm			;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 16
	jmp	endlp				;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 16

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 four_complex_first_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 8*4		;; We've already prefetched 8 blocks
pfing	add	rcx, rax
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst		;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 16 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 4 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 4*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 4 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 16 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 32 data values

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_prefetch YSINGLE		;; Prefetch 16*clm cache lines
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b9a				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 128 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 FFT of length 256 doubles.
;; Memory examples are for a 256K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 7*clm*YMM_SCD1 = 31*clm 64-byte cache lines

yr4dwpn_pass1sc256 MACRO
	LOCAL	b0b, b1b, b6b, b7b, b8b, b9a, b9aa, b9b, c0b, c1b, c6b, c7b, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 256K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 31 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 32 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_init 8*4*clm			;; 8*4*clm iterations
	yloop_set_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	4, c9a, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 28 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 7 macros each processing 32 data values

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 8*4*clm			;; 8*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	4, c7b, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...

;; Do 32 sixteen_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 4 macros each processing 64 data values

	start_timer 20
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm			;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 8 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 32
	jmp	endlp				;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 32

;; Do FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 sixteen_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 64 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 16*4		;; We've already prefetched 16 blocks
pfing	add	rcx, rax
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 8 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iters prefetching 8*clm cache lines
	yloop	4, b1b, -4*clmblkdst		;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 28 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 7 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 7*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_init 8*4*clm			;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, b7b,	-4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 31 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 32 data values

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 8*4*clm			;; 8 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YSINGLE		;; Prefetch 31*clm cache lines
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, b9a				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 256 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 negacyclic FFT of length 256 doubles.
;; Memory examples are for a 256K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD2 + clm*YMM_SCD4 + 4*clm*YMM_SCD1 = 32*clm 64-byte cache lines

yr4dwpn_pass1sc256ac MACRO
	LOCAL	b0b, b1b, b7b, b9a, b9b, c0b, c1b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 256K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 6,7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 16 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 64 data values

c0b:	start_timer 16
	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r13, [rbp+4*blkdstreg]		;; Source+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer part 1
	bump2	r12, (clm MOD 2), 8*blkdstreg	;; L1 prefetch pointer part 2
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch pointer + 4*blkdst
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_init 4*4*clm			;; 4*4*clm iterations
	yloop_set_prefetch YNONE		;; Prefetch no blocks
c9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	4, c9a, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 8*4*clm			;; 8*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, restore sin/cos pointers
	yloop	4, c7b,	-4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...

;; Do 32 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 8 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 32
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 32

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 four_complex_first_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 32 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	mov	r8, pass2blkdst		;; blkdst
pfing	imul	rax, blkdstreg, 16*4	;; We've already prefetched 16 blocks
pfing	add	rcx, rax
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE	;; Prefetch 8 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst	;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 32 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 8 macros each processing 32 data values

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 4*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_init 8*4*clm			;; 8 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 8 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, restore sin/cos ptrs
	yloop	4, b7b, -4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

;; Do FFT levels 6,7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 16 eight_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 4 macros each processing 64 data values

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
	yloop_init 4*4*clm			;; 4 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YDOUBLE		;; Prefetch 32*clm cache lines
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	4, b9a				;; Test loop counter
	end_timer 26

;; Work on next 4*clm sets of 256 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM



;; Perform a shared pass 1 FFT of length 320 doubles.
;; Memory examples are for a 320K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 9*clm*YMM_SCD1 = 33*clm 64-byte cache lines

;; This pass processes 160*clm cache lines, or 40KB if clm=4, suggesting we should use clm=4:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc320 MACRO
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 320K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 39 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 36 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 9 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (40*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)
	yloop_init 10*4*clm			;; 10*4*clm iterations
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
 
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+9*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 9 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	5, c9a, -5*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 10*4*clm			;; 10*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	5, c9a, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 10*4*clm			;; 10*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 9 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	5, c7b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...

;; Do 16 twenty_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 80 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 40
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 40

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 80 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	mov	r8, pass2blkdst		;; blkdst
pfing	imul	rax, blkdstreg, (27-3)*4;; We've already prefetched 27 blocks which will be 3 too many
pfing	add	rcx, rax
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	4, b1b, -4*clmblkdst ;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 36 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 9 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 39 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (40*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+9*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 10*4*clm			;; 10 iterations of 4*clm
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 18*clm cache lines
	yloop_set_alternate_prefetch_increment 33, (18+20)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Loop, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YHALF		;; Prefetch 20*clm cache lines
	yloop_set_alternate_prefetch_increment 33, (18+20)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 9*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 10*4*clm			;; 10 iterations of 4*clm
	yloop_set_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 18*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b7b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 10*4*clm			;; 10 iters of 4*clm
pfing	bump	rcx, (33-18-20)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YHALF		;; Prefetch 20*clm cache lines
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	5, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 320 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 FFT of length 384 doubles.
;; Memory examples are for a 384K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 11*clm*YMM_SCD1 = 35*clm 64-byte cache lines

;; This pass processes 192*clm cache lines, or 48KB if clm=4, suggesting we should use clm=4:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc384 MACRO
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 384K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 47 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 44 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 11 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 12*4*clm			;; 12*4*clm iterations
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+11*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, c9a, -6*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	6, c9a, -6*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, c7b, -6*clmblkdst8		;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...

;; Do 16 twenty_four_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 96 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 8 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 48
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 48

;; Do FFT levels 1,2,3,4,5 (actually 4.565 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_four_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 96 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 32*4		;; We've already prefetched 32 blocks
pfing	add	rcx, rax
	yloop_init 4*4*clm			;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst		;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 44 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 11 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 47 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+11*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 12*4*clm			;; 12 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YHALF		;; Prefetch 2*clm cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdst, blkdst3reg, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 22*clm cache lines
	yloop_set_alternate_prefetch_increment 35, (2+22+12)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 12*clm cache lines
	yloop_set_alternate_prefetch_increment 35, (2+22+12)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	6, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 11*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iterations of 4*clm
	yloop_set_prefetch YHALF		;; Prefetch 2*clm cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 22*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, restore source pointer
	yloop	6, b7b, -6*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
pfing	bump	rcx, (35-2-22-12)*clm*64	;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 12*clm cache lines
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	6, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 384 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 negacyclic FFT of length 384 doubles.
;; Memory examples are for a 384K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 12*clm*YMM_SCD1 = 26*clm 64-byte cache lines

;; This pass processes 192*clm cache lines, or 48KB if clm=4, suggesting we should use clm=4:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc384ac MACRO
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 384K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 48 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 12 macros each processing 32 data values

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD2		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+12*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 12*4*clm			;; 12*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	12, c9a, -12*4*clmblkdst	;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	12, c9a, -4*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	12, c7b, -12*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 64 three_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 24 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...

;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 48K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+18 cache lines of s/c data.
;; A grand total of 16000 bytes with clm=4 -- easily fits in a 32KB L1 cache.

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16 or 12 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+12*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+12*clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*12*clmblkdst, rdi, YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -3*4*clmblkdst+clmblkdst, rbp, -3*4*YMM_SCD6+YMM_SCD6 ;; Loop 3 times!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter, restore source pointer

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+12*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD1 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, c5b, -4*clmblkdst+12*clmblkdst, rdi, -4*YMM_SCD1 ;; 4 iterations, restore sin/cos ptr
	yloop	4, c5b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 12*4*clm			;; 12 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	12, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 48
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 48

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 48 four_complex_first_fft operations
;;	distance between fft data elements is 48K
;;	do 12 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 three_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 18+4 cache lines of s/c data.
;; A grand total of 16000 bytes with clm=4 -- easily fits in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 28*4		;; We've already prefetched 28 blocks
pfing	add	rcx, rax

IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+12*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 16*4*clm			;; 12 or 16 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -3*4*clmblkdst, rdi, -3*4*YMM_SCD6+YMM_SCD6 ;; 3 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rbp, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+12*clmblkdst ;; 4*clm iterations
	yloop	4, b5b, -4*12*clmblkdst+clmblkdst, rbp, YMM_SCD1 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 12 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	12, b1b, -12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD1 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+12*clmblkdst, rdi, -4*YMM_SCD1 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*12*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 12 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (48*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+4*clm*64+clm*YMM_SCD2+12*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 12*clm cache lines
	yloop_set_alternate_prefetch_increment 26, (12+24)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
	yloop_set_alternate_prefetch_increment 26, (12+24)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	12, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 12*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 12*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
pfing	bump	rcx, (26-12-24)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	yloop	12, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 384 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 FFT of length 448 doubles.
;; Memory examples are for a 448K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 14*clm*YMM_SCD1 = 37*clm 64-byte cache lines

;; This pass processes 224*clm cache lines, or 56KB if clm=4, suggesting we should use clm=4:  56KB of scratch area, 56KB of input FFT data,
;; 56KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc448 MACRO
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 448K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 55 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 52 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 13 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (56*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 14*4*clm			;; 14*4*clm iterations
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+13*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 14 blocks
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 13 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	7, c9a, -7*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 14*4*clm			;; 14*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 14 blocks
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	7, c9a, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 14*4*clm			;; 14*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 13 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	7, c7b, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	224K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	220K	...

;; Do 16 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 112 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 4*4*clm		;; 4 iterations of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	4, c1b			;; 4 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 56
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 56

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	224K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	220K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 twenty_eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 iterations each processing 112 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	mov	r8, pass2blkdst		;; blkdst
pfing	imul	rax, blkdstreg, (43-3)*4 ;; We've already prefetched 43 blocks which will be 3 too many
pfing	add	rcx, rax
	yloop_init 4*4*clm		;; 4 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 16 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 52 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 13 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 55 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (56*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+13*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 14*4*clm			;; 14 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 26*clm cache lines
	yloop_set_alternate_prefetch_increment 37, (26+14)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 14*clm cache lines
	yloop_set_alternate_prefetch_increment 37, (26+14)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	7, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 13*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 14*4*clm			;; 14 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 26*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	7, b7b, -7*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 14*4*clm			;; 14 iters of 4*clm
pfing	bump	rcx, (37-26-14)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 14*clm cache lines
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	7, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 448 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 FFT of length 512 doubles.
;; Memory examples are for a 512K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 15*clm*YMM_SCD1 = 39*clm 64-byte cache lines

;; This pass processes 256*clm cache lines, or 64KB if clm=4, suggesting we should use clm=4:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

IFDEF SLOWER_BUT_USES_LESS_MEMORY
yr4dwpn_pass1sc512 MACRO
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 512K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 63 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 60 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 15 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16*4*clm iterations
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+15*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	8, c7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 48 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...

;; Do 64 eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+12 cache lines of s/c data.
;; A grand total of 19200 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rdi+16*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+2*clmblkdst8 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+2*clmblkdst8 ;; Test loop counter
	yloop	4, c5b, -4*2*clmblkdst8, rbx, YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 18
	loops_undo 4*4*clm

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD3 ;; Test loop counter
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	2, c1b, -2*clmblkdst8+clmblkdst, rdi, -4*4*YMM_SCD3+YMM_SCD3 ;; 2 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 16*YMM_SCD3		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations

	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sine/cosine pointer
	yloop	4, c5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -16*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 64
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 64

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 48 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 12 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 12+4 cache lines of s/c data.
;; A grand total of 19200 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 40*4		;; We've already prefetched 40 blocks
pfing	add	rcx, rax

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+16*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD3 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, b1b, -2*clmblkdst8, rdi, -4*4*YMM_SCD3+YMM_SCD3 ;; 2 iterations, restore source pointer, next sin/cos ptr
	loops_undo 2*2*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b4b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YHALF
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*2*clmblkdst8+clmblkdst, rbx, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3	;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 60 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 15 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 63 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 32 data values

;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+15*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YHALF		;; Prefetch 30*clm cache lines
	yloop_set_alternate_prefetch_increment 39, (30+15)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 15*clm cache lines
	yloop_set_alternate_prefetch_increment 39, (30+15)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 15*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 30*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (39-30-15)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 15*clm cache lines
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 512 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF


;; Perform a shared pass 1 FFT of length 512 doubles.
;; Memory examples are for a 512K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 7*clm*YMM_SCD1 = 55*clm 64-byte cache lines
;;
;; This pass processes 256*clm cache lines, or 64KB if clm=4, suggesting we should use clm=4:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc512 MACRO
	LOCAL	b0b, b1a, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 512K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 7,8,9
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 31 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 64 data values

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 56 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 14 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r13, [rbp+4*blkdstreg]		;; Source+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer part 1
	bump2	r12, (clm MOD 2), 8*blkdstreg	;; L1 prefetch pointer part 2
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch pointer + 4*blkdst

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 8*4*clm or 16*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+7*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 16 blocks
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 8*4*clm			;; 8*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 16 blocks
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	8, c7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...

;; Do 32 sixteen_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 64 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 64
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 64

;; Do FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 sixteen_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 64 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	mov	r8, pass2blkdst		;; blkdst
pfing	imul	rax, blkdstreg, 48*4	;; We've already prefetched 48 blocks
pfing	add	rcx, rax
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst	;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 56 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 14 macros each processing 32 data values

;; Do FFT levels 7,8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 31 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 7.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+7*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 or 8 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 28*clm cache lines
	yloop_set_alternate_prefetch_increment 55, (28+31)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 31*clm cache lines
	yloop_set_alternate_prefetch_increment 55, (28+31)
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	16, b7a				;; 8 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 7*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 28*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	8, b7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
	yloop_init 8*4*clm			;; 8 iters of 4*clm
pfing	bump	rcx, (55-28-31)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YSINGLE		;; Prefetch 31 cache lines
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 512 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 negacyclic FFT of length 512 doubles.
;; Memory examples are for a 512K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 = 30*clm 64-byte cache lines

;; This pass processes 256*clm cache lines, or 64KB if clm=4, suggesting we should use clm=4:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc512ac MACRO
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 512K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 64 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD2		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+16*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	8, c9a, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	8, c7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...

;; Do 64 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 16*4*clm			;; 16*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+16*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations
	yloop	4, c5b, -4*2*clmblkdst8, rdi, YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, c1b, -2*clmblkdst8+clmblkdst, rbp, -4*4*YMM_SCD6+YMM_SCD6 ;; 2 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+16*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 64
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 64

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 four_complex_first_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 24+8*clm cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 40*4		;; We've already prefetched 40 blocks
pfing	add	rcx, rax

IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+16*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 16*4*clm			;; 16 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations
	yloop	2, b1b, -2*clmblkdst8, rdi, -4*4*YMM_SCD6+YMM_SCD6 ;; 2 iterations, restore source ptr, next sin/cos ptr
	loops_undo 2*2*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+2*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*2*clmblkdst8+clmblkdst, rbp, YMM_SCD2 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations
	end_timer 22

	start_timer 24
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YHALF		;; Prefetch 8 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*2*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 16 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 64 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (64*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+4*clm*64+clm*YMM_SCD2+16*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 16*4*clm			;; 16 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
	yloop_set_alternate_prefetch_increment 30, (16+16)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, r9
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
	yloop_set_alternate_prefetch_increment 30, (16+16)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b7b, -8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (30-16-16)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 512 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 FFT of length 640 doubles.
;; Memory examples are for a 640K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 9*clm*YMM_SCD1 = 57*clm 64-byte cache lines
;;
;; This pass processes 320*clm cache lines, or 80KB if clm=4, suggesting we should use clm=4:  80KB of scratch area, 80KB of input FFT data,
;; 80KB of prefetched FFT data, plus s/c data.  This might fit in 256KB L2 cache.

yr4dwpn_pass1sc640 MACRO
	LOCAL	b0b, b1a, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 640K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 39 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 72 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r13, [rbp+4*blkdstreg]		;; Source+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer part 1
	bump2	r12, (clm MOD 2), 8*blkdstreg	;; L1 prefetch pointer part 2
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch pointer + 4*blkdst

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 20*4*clm			;; 10*4*clm or 20*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+9*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	10, c9a, -10*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 10*4*clm			;; 10*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YSINGLE
	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 10 blocks
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	10, c9a, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	10, c7b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K	...

;; Do 32 twenty_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 80 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 80
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 80

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 80 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	mov	r8, pass2blkdst		;; blkdst
pfing	imul	rax, blkdstreg, 46*4	;; We've already prefetched 46 blocks which will be 2 too few!
pfing	add	rcx, rax
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst	;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 72 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 39 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 9.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+9*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 or 10 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 18*clm cache lines
	yloop_set_alternate_prefetch_increment 57, (18+39)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 39*clm cache lines
	yloop_set_alternate_prefetch_increment 57, (18+39)
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	20, b7a				;; 10 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 9*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 18*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	10, b7b, -10*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
	yloop_init 10*4*clm			;; 10 iters of 4*clm
pfing	bump	rcx, (57-18-39)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YSINGLE		;; Prefetch 39 cache lines
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	10, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 640 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 negacyclic FFT of length 640 doubles.
;; Memory examples are for a 640K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 20*clm*YMM_SCD1 = 34*clm 64-byte cache lines

;; This pass processes 320*clm cache lines, or 80KB if clm=4, suggesting we should use clm=4:  80KB of scratch area, 80KB of input FFT data,
;; 80KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc640ac MACRO
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 640K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 80 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 32 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 80 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD2		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+20*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 20*4*clm			;; 20*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	20, c9a, -20*4*clmblkdst	;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 20*4*clm			;; 20*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4cl_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4cl_four_complex_unfft4 rbp, 64, blkdst, 2*blkdst, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*4*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	20, c9b, -4*20*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	20, c7b, -20*4*clmblkdst, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...

;; Do 64 five_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 40 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K	...

;; Do 80 four_complex_unfft operations
;;	distance between fft data elements is 80K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 16 or 20 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+20*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+20*clmblkdst ;; 4*clm iterations
	yloop	8, c5b, -4*20*clmblkdst, rdi, YMM_SCD2 ;; 4 iterations!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -5*4*clmblkdst+clmblkdst, rbp, -5*4*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+20*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 4 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, c5b, -4*clmblkdst+20*clmblkdst, rdi, -4*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 20*4*clm			;; 20 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	20, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 80
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 80

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	320K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	316K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...

;; Do 80 four_complex_first_fft operations
;;	distance between fft data elements is 80K
;;	do 20 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	80K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	76K	...
;;	160K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 64 five_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 16 macros each processing 40 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 30+8*clm cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 44*4		;; We've already prefetched 44 blocks
pfing	add	rcx, rax

IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+20*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 32*4*clm			;; 20 or 16 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+4*clmblkdst, rdi, 4*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -5*4*clmblkdst, rdi, -5*4*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, 4*clmblkdst, rbp, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+20*clmblkdst ;; 4*clm iterations
	yloop	8, b5b, -4*20*clmblkdst+clmblkdst, rbp, YMM_SCD2 ;; 4 iterations!! next source pointer, next sin/cos ptr
	end_timer 24

	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 20 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 20*clmblkdst, 40*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	20, b1b, -20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, 4*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+20*clmblkdst, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*20*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 80 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 20 macros each processing 32 data values

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 80 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (80*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+4*clm*64+clm*YMM_SCD2+20*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
	yloop_set_alternate_prefetch_increment 34, (20+20)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer. restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
	yloop_set_alternate_prefetch_increment 34, (20+20)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	20, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + 20*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	20, b7b, -20*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
pfing	bump	rcx, (34-20-20)*clm*64		;; Finish prefetching the sin/cos/premult data
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	yloop	20, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 640 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 FFT of length 768 doubles.
;; Memory examples are for a 768K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 11*clm*YMM_SCD1 = 59*clm 64-byte cache lines

;; This pass processes 384*clm cache lines, or 96KB if clm=4, suggesting we should use clm=2:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc768 MACRO
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 768K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 47 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 88 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 22 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r13, [rbp+4*blkdstreg]		;; Source+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer part 1
	bump2	r12, (clm MOD 2), 8*blkdstreg	;; L1 prefetch pointer part 2
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch pointer + 4*blkdst

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 24*4*clm			;; 12*4*clm or 24*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+11*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 24 blocks
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	12, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 12*4*clm			;; 12*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 24 blocks
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	12, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 24*4*clm			;; 24*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	12, c7b, -12*clmblkdst8, rdi, 2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...

;; Do 32 twenty_four_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 96 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE	;; Prefetch 16 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 96
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 96

;; Do FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_four_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 96 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 64*4		;; We've already prefetched 64 blocks
pfing	add	rcx, rax
	yloop_init 8*4*clm			;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD		;; Prefetch 32 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst		;; 8 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 72 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 18 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 47 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 11.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+11*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 or 12 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 22*clm cache lines
	yloop_set_alternate_prefetch_increment 59, (22+47)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
	yloop_set_alternate_prefetch_increment 59, (22+47)
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	24, b7a				;; 12 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 11*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 22*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
	yloop_init 12*4*clm			;; 12 iters of 4*clm
pfing	bump	rcx, (59-22-47)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YSINGLE		;; Prefetch 47*clm cache lines
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	12, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 768 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 negacyclic FFT of length 768 doubles.
;; Memory examples are for a 768K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD2 + clm*YMM_SCD4 + 12*clm*YMM_SCD1 = 40*clm 64-byte cache lines

;; This pass processes 384*clm cache lines, or 96KB if clm=4, suggesting we should use clm=2:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This ought to fit in 256KB L2 cache.

yr4dwpn_pass1sc768ac MACRO
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 768K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 48 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines of input FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- marginally fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r13, [rbp+4*blkdstreg]		;; Source+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer part 1
	bump2	r12, (clm MOD 2), 8*blkdstreg	;; L1 prefetch pointer part 2
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch pointer + 4*blkdst

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD4		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+12*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 24*4*clm			;; 12*4*clm or 24*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	12, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_init 12*4*clm			;; 12*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	12, c9a, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 24*4*clm			;; 24*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	12, c7b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...

;; Do 128 three_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 24 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...

;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 96K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+100% prefetching next scratch area section) + 4*clm+24 cache lines of s/c data.
;; A grand total of 27136 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 32 or 24 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+24*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c5b, -4*clm*64+3*clmblkdst8 ;; 4*clm iterations
	yloop	4, c5b, -4*3*clmblkdst8, rdi, YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -3*clmblkdst8+clmblkdst, rbp, -3*8*YMM_SCD6+YMM_SCD6 ;; Loop 3 times!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+24*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD1 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, c5b, -8*clmblkdst+3*clmblkdst8, rdi, -8*YMM_SCD1 ;; 8 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 24*4*clm			;; 24 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8	;; Test loop counter
	yloop	3, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 96
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 96

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	384K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	380K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...

;; Do 96 four_complex_first_fft operations
;;	distance between fft data elements is 96K
;;	do 24 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	96K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	92K	...
;;	192K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 three_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 48*clm cache lines of data (+100% prefetching next scratch area section) + 24+4*clm cache lines of s/c data.
;; A grand total of 27136 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 64*4		;; We've already prefetched 64 blocks
pfing	add	rcx, rax

IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+24*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 32*4*clm			;; 24 or 32 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -3*clmblkdst8, rdi, -3*8*YMM_SCD6+YMM_SCD6 ;; 3 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, clmblkdst
	yloop	4*clm, b5b, -4*clm*64+3*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*3*clmblkdst8+clmblkdst, rbp, YMM_SCD1 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 24*4*clm			;; 24 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 24 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 3*clmblkdst8, 6*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	3, b1b, -3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD1 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b5b, -8*clmblkdst+3*clmblkdst8, rdi, -8*YMM_SCD1 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*3*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 96 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 24 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 48 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 12 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (96*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+2*4*clm*64+clm*YMM_SCD4+12*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 or 12 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 24*clm cache lines
	yloop_set_alternate_prefetch_increment 40, (24+24)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
	yloop_set_alternate_prefetch_increment 40, (24+24)
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	24, b7a				;; 12 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 12*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 24*4*clm			;; 24 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 24*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	12, b7b, -12*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
	yloop_init 12*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (40-24-24)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YHALF		;; Prefetch 24*clm cache lines
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	12, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 768 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 FFT of length 896 doubles.
;; Memory examples are for a 896K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 13*clm*YMM_SCD1 = 61*clm 64-byte cache lines

;; This pass processes 448*clm cache lines, or 112KB if clm=4, suggesting we should use clm=2:  56KB of scratch area, 56KB of input FFT data,
;; 56KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc896 MACRO
	LOCAL	b0b, b1b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b, c0b, c1b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 896K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 55 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 104 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 26 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r13, [rbp+4*blkdstreg]		;; Source+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer part 1
	bump2	r12, (clm MOD 2), 8*blkdstreg	;; L1 prefetch pointer part 2
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch pointer + 4*blkdst

IF (112*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 28*4*clm			;; 14*4*clm or 28*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+13*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 28 blocks
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 26 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	14, c9a, -14*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 14*4*clm			;; 14*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YDOUBLE
	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 28 blocks
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	14, c9a, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 28*4*clm			;; 28*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 26 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst ;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	14, c7b, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	448K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	444K	...

;; Do 32 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 112 data values

	start_timer 20
	mov	rdi, sincos2		;; Load fixed sin/cos data ptr
	yloop_init 8*4*clm		;; 8 iterations of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	8, c1b			;; 8 iterations
	end_timer 20

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 112
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 112

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	448K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	444K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 twenty_eight_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 iterations each processing 112 data values

yes_fft:start_timer 22
	mov	rsi, scratch_area	;; Get address of scratch area
	mov	rdi, sincos2		;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs		;; Init prefetching pointers
pfing	mov	r8, pass2blkdst		;; blkdst
pfing	imul	rax, blkdstreg, (86-6)*4 ;; We've already prefetched 86 blocks which will be 6 too many
pfing	add	rcx, rax
	yloop_init 8*4*clm		;; 8 iters of 4*clm
	yloop_set_clm_prefetch YQUAD	;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst	;; 4 iterations, restore source pointer
	end_timer 22

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 104 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 26 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 55 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 13.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (112*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+13*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 28*4*clm			;; 28 or 14 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YHALF		;; Prefetch 52*clm cache lines
	yloop_set_alternate_prefetch_increment 61, (52+28)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YHALF		;; Prefetch 28*clm cache lines
	yloop_set_alternate_prefetch_increment 61, (52+28)
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	28, b7a				;; 14 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 13*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 28*4*clm			;; 28 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YHALF		;; Prefetch 52*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	14, b7b, -14*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
	yloop_init 14*4*clm			;; 14 iters of 4*clm
pfing	bump	rcx, (61-52-28)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YHALF		;; Prefetch 28*clm cache lines
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	14, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 896 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 FFT of length 1024 doubles.
;; Memory examples are for a 1024K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 15*clm*YMM_SCD1 = 63*clm 64-byte cache lines

;; This pass processes 512*clm cache lines, or 128KB if clm=4, suggesting we should use clm=2:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.

yr4dwpn_pass1sc1024 MACRO
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1024K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 63 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 120 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 30 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r13, [rbp+4*blkdstreg]		;; Source+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer part 1
	bump2	r12, (clm MOD 2), 8*blkdstreg	;; L1 prefetch pointer part 2
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch pointer + 4*blkdst

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 16*4*clm or 32*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+15*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	16, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 16*4*clm			;; 16*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	16, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	16, c7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macro processing 32 data values
;; Do 96 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...

;; Do 128 eight_reals_unfft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+12 cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rdi+32*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+4*clmblkdst8 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+4*clmblkdst8 ;; Test loop counter
	yloop	4, c5b, -4*4*clmblkdst8, rbx, YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 18
	loops_undo 4*4*clm

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD3 ;; Test loop counter
	yloop	4, c1b, -4*clmblkdst8+clmblkdst, rdi, -4*8*YMM_SCD3+YMM_SCD3 ;; 4 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 32*YMM_SCD3		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, c4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; 8 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -32*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 128
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 128

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 eight_reals_fft operations
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values
;; Do 96 four_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 24 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 12+4 cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 80*4		;; We've already prefetched 80 blocks
pfing	add	rcx, rax

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+32*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD3 ;; 4*clm iters, next source ptr, next sin/cos ptr
	yloop	4, b1b, -4*clmblkdst8, rdi, -4*8*YMM_SCD3+YMM_SCD3 ;; 4 iterations, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b4b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*4*clmblkdst8+clmblkdst, rbx, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3	;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, b1b, -4*clmblkdst8		;; 4 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 120 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 30 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 63 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 15.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+15*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 or 16 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yloop_set_alternate_prefetch_increment 63, (0+63)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
	yloop_set_alternate_prefetch_increment 63, (0+63)
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	32, b7a				;; 16 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 15*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (63-0-63)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8clreg_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YSINGLE		;; Prefetch 63*clm cache lines
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	16, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1024 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 negacyclic FFT of length 1024 doubles.
;; Memory examples are for a 1024K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD2 + clm*YMM_SCD4 + 16*clm*YMM_SCD1 = 44*clm 64-byte cache lines

;; This pass processes 512*clm cache lines, or 128KB if clm=4, suggesting we should use clm=2:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.

yr4dwpn_pass1sc1024ac MACRO
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1024K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 64 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines of input FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- marginally fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r13, [rbp+4*blkdstreg]		;; Source+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer part 1
	bump2	r12, (clm MOD 2), 8*blkdstreg	;; L1 prefetch pointer part 2
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch pointer + 4*blkdst

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD4		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+16*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 32*4*clm			;; 16*4*clm or 32*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	16, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_init 16*4*clm			;; 16*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	16, c9a, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	16, c7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...

;; Do 128 four_complex_unfft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 32*4*clm			;; 32*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+32*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations
	yloop	4, c5b, -4*4*clmblkdst8, rdi, YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 18

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	4, c1b, -4*clmblkdst8+clmblkdst, rbp, -4*8*YMM_SCD6+YMM_SCD6 ;; 4 iterations, next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+32*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, c5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD2 ;; 8 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 128
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 128

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	512K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	508K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 four_complex_first_fft operations
;;	distance between fft data elements is 128K
;;	do 32 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 four_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 64*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+24 cache lines of s/c data.
;; A grand total of 22016 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 80*4		;; We've already prefetched 80 blocks
pfing	add	rcx, rax

IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+32*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 32*4*clm			;; 32 iters of 4*clm
b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	4, b1b, -4*clmblkdst8, rdi, -4*8*YMM_SCD6+YMM_SCD6 ;; 4 iterations, restore source ptr, next sin/cos ptr
	loops_undo 4*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations
	yloop	4, b5b, -4*4*clmblkdst8+clmblkdst, rbp, YMM_SCD2 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, b1b, -4*clmblkdst8		;; 4 iterations
	end_timer 22

	start_timer 24
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YHALF		;; Prefetch 16 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 128 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 32 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 64 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 16 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (128*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+2*4*clm*64+clm*YMM_SCD4+16*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 or 16 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 32*clm cache lines
	yloop_set_alternate_prefetch_increment 44, (32+16)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
	yloop_set_alternate_prefetch_increment 44, (32+16)
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	32, b7a				;; 16 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 16*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 32*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b7b, -16*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
	yloop_init 16*4*clm			;; 16 iters of 4*clm
pfing	bump	rcx, (44-32-16)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 16*clm cache lines
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	16, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1024 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 FFT of length 1280 doubles.
;; Memory examples are for a 1280K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 39*clm*YMM_SCD1 = 63*clm 64-byte cache lines

;; This pass processes 640*clm cache lines, or 160KB if clm=4, suggesting we should use clm=1:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1280 MACRO
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1280K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 159 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 39.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 156 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 39 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+24*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 40*4*clm			;; 40*4*clm iterations
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+39*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	20, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 40*4*clm			;; 40*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	20, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	20, c7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 144 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 36 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K	...

;; Do 64 twenty_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 80 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 160 cache lines of data (+1/10 due to ineffective L1 prefetching) + 4+36 cache lines of s/c data.
;; A grand total of 12800 bytes -- should fit in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rdi, [rbp+16*YMM_SCD9]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 40*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 6*4			;; Do 40 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8	;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -10*2*clmblkdst8	;; 10 iterations!!  Restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 6*2*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD9 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD9 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD9, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 16*YMM_SCD9		;; Sin/cos ptr
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	10, c5b, -10*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -16*YMM_SCD9		;; Next fixed sine/cosine pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr5_10cl_20_reals_unfft_preload
c1b:	yr5_10cl_20_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 160
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 160

;; Do FFT levels 1,2,3,4,5 (actually 4.32 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 80 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 144 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 36 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 160 cache lines of data (+1/4 due to ineffective L1 prefetching) + 36+4 cache lines of s/c data.
;; A grand total of 12800 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 92*4		;; We've already prefetched 92 blocks
pfing	add	rcx, rax

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rdi, [rbp+16*YMM_SCD9]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 16 or 40 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr5_10cl_20_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD9 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD9 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 6*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	16, b5b, -10*2*clmblkdst8+4*64	;; 10 iterations!!  Next source pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD9, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr5_10cl_20_reals_fft_preload
b1b:	yr5_10cl_20_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD9 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; Test loop counter, next source ptr, next sin/cos ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 36 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4	;; Test loop counter, next source pointer, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	10, b5b, -10*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 156 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 39 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 159 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 39.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 24*clm+4*clm cache lines of s/c data.
;; A grand total of 19456 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+39*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 40*4*clm			;; 40 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 39*clm cache lines
	yloop_set_alternate_prefetch_increment 63, (39+40)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 40*clm cache lines
	yloop_set_alternate_prefetch_increment 63, (39+40)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	20, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 39*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 39*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	20, b7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 40*4*clm			;; 40 iters of 4*clm
pfing	bump	rcx, (63-39-40)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 40*clm cache lines
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	20, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1280 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 negacyclic FFT of length 1280 doubles.
;; Memory examples are for a 1280K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD2 + clm*YMM_SCD4 + 20*clm*YMM_SCD1 = 48*clm 64-byte cache lines

;; This pass processes 640*clm cache lines, or 160KB if clm=4, suggesting we should use clm=1:  40KB of scratch area, 40KB of input FFT data,
;; 40KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1280ac MACRO
	LOCAL	b0b, b1a, b1b, b5b, b7a, b7b, b9a, b9b, c0b, c1b, c5a, c5b, c7b, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1280K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 80 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 64 data values

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 160 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+24*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r13, [rbp+4*blkdstreg]		;; Source+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer part 1
	bump2	r12, (clm MOD 2), 8*blkdstreg	;; L1 prefetch pointer part 2
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch pointer + 4*blkdst

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	bump	rdi, clm*YMM_SCD4		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+20*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 40*4*clm			;; 20*4*clm or 40*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointer
	end_timer 17

	yloop	20, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_init 20*4*clm			;; 20*4*clm iterations
	yloop_set_clm_prefetch YNONE
c9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr8_rsc_sg8clreg_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8clreg_eight_complex_unfft8 rbp, 64, blkdstreg, blkdst3reg, r13, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, r12, r14 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	20, c9a, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 40*4*clm			;; 40*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Loop, next source ptr, restore sin/cos pointers
	yloop	20, c7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...

;; Do 128 five_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 40 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K	...

;; Do 160 four_complex_unfft operations
;;	distance between fft data elements is 160K
;;	do 40 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 32 or 40 iters of 4*clm
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+40*YMM_SCD6]		;; Sin/cos ptr

c5a:	start_timer 18
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+5*clmblkdst8 ;; 4*clm iterations
	yloop	8, c5b, -4*5*clmblkdst8, rdi, YMM_SCD2 ;; 4 iterations!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rbp, 8*YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -5*clmblkdst8+clmblkdst, rbp, -5*8*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c5a				;; Test loop counter

ELSE

	start_timer 18
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rdi, [rbp+40*YMM_SCD6]		;; Sin/cos ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YQUARTER		;; Prefetch 8 blocks
	yr5_5cl_five_complex_djbunfft_preload
c5b:	yr5_5cl_five_complex_djbunfft rsi, 64, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, c5b, -8*clmblkdst+5*clmblkdst8, rdi, -8*YMM_SCD2 ;; 4 iterations, restore sin/cos pointer
	yloop	4, c5b, -4*5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	yloop_init 40*4*clm			;; 40 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rbp, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rbp, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	5, c1b				;; Test loop counter
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 160
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 160

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	640K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	636K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...

;; Do 160 four_complex_first_fft operations
;;	distance between fft data elements is 160K
;;	do 40 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	160K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	156K	...
;;	320K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 128 five_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 32 macros each processing 40 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 80*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 8*clm+30 cache lines of s/c data.
;; A grand total of 27008 bytes with clm=4 -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 88*4		;; We've already prefetched 88 blocks
pfing	add	rcx, rax

IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbp, [rdi+40*YMM_SCD6]		;; Address of sin/cos table
	yloop_init 64*4*clm			;; 40 or 32 iters of 4*clm
b1a:	start_timer 22
	yloop_adjust 3*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch a short distance ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD6 ;; 4*clm iters
	yloop	8, b1b, -5*clmblkdst8, rdi, -5*8*YMM_SCD6+YMM_SCD6 ;; 5 iterations!! restore source ptr, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, clmblkdst8, rbp, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+5*clmblkdst8 ;; 4*clm iterations
	yloop	8, b5b, -4*5*clmblkdst8+clmblkdst, rbp, YMM_SCD2 ;; 4 iterations!! next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 40*4*clm			;; 40 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 40 blocks
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 5*clmblkdst8, 10*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	5, b1b, -5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr5_5cl_five_complex_djbfft_preload
b5b:	yr5_5cl_five_complex_djbfft rsi, 64, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b5b, -8*clmblkdst+5*clmblkdst8, rdi, -8*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b5b, -4*5*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 160 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 40 macros each processing 32 data values

;; Do FFT levels 8,9,10
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 80 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 20 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 24*clm+8*clm cache lines of s/c data.
;; A grand total of 32768 bytes with clm=4 -- barely fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (160*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	lea	rdi, [rdx+2*4*clm*64+clm*YMM_SCD4+20*clm*YMM_SCD1] ;; Sin/cos ptr for timer 25
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 or 20 iters of 4*clm

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 40*clm cache lines
	yloop_set_alternate_prefetch_increment 48, (40+20)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptrs
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
	yloop_set_alternate_prefetch_increment 48, (40+20)
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	40, b7a				;; 20 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + 20*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 40*4*clm			;; 40 iters of 4*clm
	yloop_set_prefetch YQUARTER		;; Prefetch 40*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	20, b7b, -20*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r13, [rbp+4*blkdstreg]		;; Dest+4*blkdst pointer
	lea	r12, [rbp+8*blkdstreg]		;; L1 prefetch pointer
	lea	r14, [r12+4*blkdstreg]		;; L1 prefetch+4*blkdst pointer
	yloop_init 20*4*clm			;; 20 iters of 4*clm
pfing	bump	rcx, (48-40-20)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 20*clm cache lines
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr8_rsc_sg8clreg_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8clreg_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdstreg, blkdst3reg, r13, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, r12, r14
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdstreg, r13, -clm*64+8*blkdstreg, rdx, -clm*YMM_SCD8, r12, -clm*64+8*blkdstreg, r14, -clm*64+8*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	20, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1280 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 FFT of length 1536 doubles.
;; Memory examples are for a 1536K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 47*clm*YMM_SCD1 = 71*clm 64-byte cache lines

;; This pass processes 768*clm cache lines, or 192KB if clm=4, suggesting we should use clm=1:  48KB of scratch area, 48KB of input FFT data,
;; 48KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1536 MACRO
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1536K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 191 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 47.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 188 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 47 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 48*4*clm			;; 48*4*clm iterations
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+47*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	24, c9a, -24*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 48*4*clm			;; 48*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	24, c9a, -24*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	24, c7b, -24*clmblkdst8		;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 176 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 44 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...

;; Do 64 twenty_four_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 96 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/12 due to ineffective L1 prefetching) + 24+44 cache lines of s/c data.
;; A grand total of 17664 bytes -- should fit in a 32KB L1 cache.

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rdi, [rbp+16*YMM_SCD11]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 48*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 4*4			;; Do 48 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	16, c5b, -12*2*clmblkdst8	;; 12 iterations!!  Restore source pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 6*2*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD11 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD11 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD11, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 16*YMM_SCD11		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	12, c5b, -12*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -16*YMM_SCD11		;; Next fixed sine/cosine pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr6_12cl_24_reals_unfft_preload
c1b:	yr6_12cl_24_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 192
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 192

;; Do FFT levels 1,2,3,4,5 (actually 4.585 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_four_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 96 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 176 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 44 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/4 due to ineffective L1 prefetching) + 44+24 cache lines of s/c data.
;; A grand total of 19712 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 128*4		;; We've already prefetched 128 blocks
pfing	add	rcx, rax

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rdi, [rbp+16*YMM_SCD11]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 16 or 48 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr6_12cl_24_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD11 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD11 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 4*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	16, b5b, -12*2*clmblkdst8+4*64	;; 12 iterations!!  Next source pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD11, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 16 blocks
	yr6_12cl_24_reals_fft_preload
b1b:	yr6_12cl_24_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD11 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; Test loop counter, next source ptr, next sin/cos ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4	;; Test loop counter, next source pointer, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	12, b5b, -12*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 188 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 47 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 191 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 47.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+47*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 48*4*clm			;; 48 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 47*clm cache lines
	yloop_set_alternate_prefetch_increment 71, (47+48)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 71, (47+48)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	24, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 47*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 47*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	24, b7b, -24*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm
pfing	bump	rcx, (71-47-48)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	24, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1536 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 negacyclic FFT of length 1536 doubles.
;; Memory examples are for a 1536K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*YMM_SCD1 + 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 = 46*clm 64-byte cache lines

;; This pass processes 768*clm cache lines, or 192KB if clm=4, suggesting we should use clm=1:  48KB of scratch area,
;; 48KB of input FFT data, 48KB of prefetched FFT data, plus s/c data.  This should fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1536ac MACRO
	LOCAL	b0b, b1a, b1b, b3a, b3b, b5b, b7aa, b7a, b7b, b9b
	LOCAL	c0b, c1b, c3a, c3b, c5a, c5b, c7b, c9aa, c9a, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1536K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 192 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+12*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	bump	rdi, clm*YMM_SCD2		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+16*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	yloop_init 48*4*clm			;; 48*4*clm iterations

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	end_timer 16
c9aa:	start_timer 16
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	yloop	3, c9aa				;; Test loop counter
	yloop	16, c9a, -48*4*clmblkdst	;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 48*4*clm			;; 48*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	12, c9b				;; Test loop counter, next premult/sin/cos pointer
	yloop	16, c9a, -192*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	48, c7b, -48*4*clmblkdst, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 256 three_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 24 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 48K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...

;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 192K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/16 due to ineffective L1 prefetching) + 4+6+72 cache lines of s/c data.
;; A grand total of 18304 bytes -- easily fitting in a 32KB L1 cache.

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 64*4*clm or 48*4*clm iterations
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+48*YMM_SCD6]		;; Second sin/cos ptr

c5a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4, L1PREFETCH_ALL, 12*clmblkdst ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD1 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*12*clmblkdst, rdi, 4*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 16*4
	end_timer 18

	start_timer 19
c3a:	yloop_adjust 4				;; Fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	4, c3b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD2 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer
	yloop	4, c3a, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_adjust 4*4			;; Fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4 iterations, next sin/cos ptr
	yloop	16, c1b, -12*4*clmblkdst+4*64, rbp, -12*4*YMM_SCD6 ;; 12 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c5a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbunfft_preload
c5b:	yr3_3cl_three_complex_djbunfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; 4*clm iterations, restore sin/cos pointer
	yloop	16, c5b, -16*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	bump	rdi, 48*YMM_SCD6		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos data
	yloop	12, c3b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD2 ;; 2 iterations, restore sin/cos pointer
	yloop	4, c3b, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -48*YMM_SCD6		;; Sin/cos ptr
	yloop_init 48*4*clm			;; 48 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	48, c1b				;; 48 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 192
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 192

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	768K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	764K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...

;; Do 192 four_complex_first_fft operations
;;	distance between fft data elements is 192K
;;	do 48 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	192K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	188K	...
;;	384K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	44K	...
;;	96K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 48K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	48K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	48K	...
;;	96K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 three_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 24 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 192 cache lines of data (+1/12 due to ineffective L1 prefetching) + 4+6+72 cache lines of s/c data.
;; A grand total of 18560 bytes -- easily fitting in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 144*4		;; We've already prefetched 144 blocks
pfing	add	rcx, rax

IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+48*YMM_SCD6]		;; Second sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1
	yloop_init 64*4*clm			;; 48 or 64 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 4*4			;; Fewer iterations this loop
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rbp, 0, 4, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; Test loop counter, next sin/cos ptr
	yloop	16, b1b, -12*4*clmblkdst, rbp, -12*4*YMM_SCD6 ;; 12 iterations!!  Restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
b3a:	yloop_adjust 4				;; Fewer iterations this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	4, b3b, -3*4*clmblkdst+48*clmblkdst, rbx, -3*4*YMM_SCD2 ;; 3 iterations!!  Next source pointer, restore sin/cos pointer
	yloop	4, b3a, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4
	yloop	4, b5b, -4*64+12*clmblkdst, rdi, -4*YMM_SCD1 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*12*clmblkdst+4*64, rdi, 4*YMM_SCD1 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, b1a, -4*clmblkdst, rdi, -4*clm*4*YMM_SCD1 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 48*clmblkdst, 96*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	48, b1b, -48*clmblkdst		;; 48 iterations
	end_timer 22

	start_timer 23
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 12*clmblkdst, 24*clmblkdst, rdi, 0, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos pointer
	yloop	12, b3b, -12*clmblkdst+48*clmblkdst, rdi, -12*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b3b, -4*48*clmblkdst		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
	yr3_3cl_three_complex_djbfft_preload
b5b:	yr3_3cl_three_complex_djbfft rsi, 64, 4*clmblkdst, rdi, YMM_SCD1, 4*clm, L1PREFETCH_ALL, clmblkdst ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst ;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+12*clmblkdst, rdi, -4*4*clm*YMM_SCD1 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	16, b5b, -16*12*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 48 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 12*clm+4*clm cache lines of s/c data.
;; A grand total of 16384 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD2		;; First sin/cos ptr (for timer 25)

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (192*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-4*clm*64-16*clm*YMM_SCD1] ;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm

b7aa:	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	end_timer 26

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Premultiplier/sin/cos ptr
	yloop_set_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 46, 48 ;; Prefetch 46*clm instead
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	yloop	3, b7a				;; Test loop counter
	yloop	16, b7aa			;; Test loop counter

ELSE

	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_init 48*4*clm			;; 48 iters of 4*clm
	yloop_set_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	48, b7b, -48*4*clmblkdst	;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -4*clm*64-16*clm*YMM_SCD1	;; Delayed sin/cos multipliers
	lea	rbx, [rdi-clm*YMM_SCD2]		;; Complex data sin/cos ptr (a.k.a. PREMULT_ADDR)
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 48*4*clm			;; 48 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YQUARTER		;; Prefetch 48*clm cache lines
	yloop_set_alternate_prefetch_increment 46, 48 ;; Prefetch 46*clm instead
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdst, rdx, -clm*YMM_SCD4 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	12, b9b				;; Test loop counter
	yloop	16, b9a				;; Test loop counter

ENDIF

;; Work on next 4*clm sets of 1536 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 FFT of length 1792 doubles.
;; Memory examples are for a 1792K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 55*clm*YMM_SCD1 = 79*clm 64-byte cache lines

;; This pass processes 896*clm cache lines, or 224KB if clm=4, suggesting we should use clm=1:  56KB of scratch area,
;; 56KB of input FFT data, 56KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc1792 MACRO
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 1792K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 223 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 55.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 220 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 55 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 56*4*clm			;; 56*4*clm iterations
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+55*clm*YMM_SCD1+4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 56 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	28, c9a, -28*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 56*4*clm			;; 56*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b				;; Test loop counter
	yloop	2, c9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	28, c9a, -28*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*32]		;; Weights ptr
	yloop_init 56*4*clm			;; 56*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 56 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointers
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	28, c7b, -28*clmblkdst8		;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 208 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 52 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	896K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	892K	...

;; Do 64 twenty_eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 112 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 224 cache lines of data (+1/14 due to ineffective L1 prefetching) + 24+52 cache lines of s/c data.
;; A grand total of 20224 bytes -- should fit in a 32KB L1 cache.

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rdi, [rbp+16*YMM_SCD13]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 56*4*clm or 16*4*clm iterations

c4a:	start_timer 18
	yloop_adjust 2*4			;; Do 56 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	16, c5b, -14*2*clmblkdst8	;; 14 iterations!!  Restore source pointer
	loops_undo 16*4
	end_timer 18

	start_timer 20
	yloop_adjust 6*2*4			;; Do 16 rather than 64 iterations in this loop
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD13 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -2*clmblkdst8+4*64, rbp, -4*4*YMM_SCD13 ;; 2 iterations!!  Next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbp, YMM_SCD13, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 16*YMM_SCD13		;; Sin/cos ptr
	yloop_init 56*4*clm			;; 56*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	14, c5b, -14*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -16*YMM_SCD13		;; Next fixed sine/cosine pointer
	yloop_init 16*4*clm			;; 16 iterations of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_unfft_preload
c1b:	yr7_14cl_28_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c1b				;; 2 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 224
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 224

;; Do FFT levels 1,2,3,4,5 (actually 4.81 levels)
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	896K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	892K
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 twenty_eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 iterations each processing 112 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 208 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 52 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 224 cache lines of data (+1/4 due to ineffective L1 prefetching) + 52+24 cache lines of s/c data.
;; A grand total of 22784 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 140*4		;; We've already prefetched 140 blocks
pfing	add	rcx, rax

IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rdi, [rbp+16*YMM_SCD13]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 16 or 56 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
	mov	ebx, 4*clmblkdst		;; Short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr7_14cl_28_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, rbx ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD13 ;; 4 iters, next sin/cos ptr
	xor	ebx, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b1b, -2*clmblkdst8, rbp, -4*4*YMM_SCD13 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*4
	end_timer 22

	start_timer 24
	yloop_adjust 2*4			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b4b, -4*64+2*clmblkdst8	;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4
	yloop	4, b5b, -4*64+2*clmblkdst8	;; Test loop counter
	yloop	16, b5b, -14*2*clmblkdst8+4*64	;; 14 iterations!!  Next source pointer
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbp, YMM_SCD13, rdi, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 16*4*clm			;; 16 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE 		;; Prefetch 32 blocks
	yr7_14cl_28_reals_fft_preload
b1b:	yr7_14cl_28_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD13 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations, next source pointer
	yloop	2, b1b, -2*clmblkdst8		;; 2 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 56*4*clm			;; 56 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; Test loop counter, next source ptr, next sin/cos ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 52 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4	;; Test loop counter, next source pointer, next sin/cos ptr
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdi, -4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	14, b5b, -14*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 220 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 55 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 223 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 55.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (224*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD2+clm*YMM_SCD2+55*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 56*4*clm			;; 56 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 55*clm cache lines
	yloop_set_alternate_prefetch_increment 79, (55+56)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 56*clm cache lines
	yloop_set_alternate_prefetch_increment 79, (55+56)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	28, b7a				;; Test loop counter

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*clm*64 + clm*YMM_SCD2 + clm*YMM_SCD2 + 55*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 56*4*clm			;; 56 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 55*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdx, -4*clm*32, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	28, b7b, -28*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 56*4*clm			;; 56 iters of 4*clm
pfing	bump	rcx, (79-55-56)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointer, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 56*clm cache lines
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	2, b9a, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	28, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 1792 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a pass 1 FFT of length 2048 doubles.
;; Memory examples are for a 2048K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 2*4*clm*64 + 2*4*clm*YMM_SCD4 + clm*YMM_SCD4 + clm*YMM_SCD4 + 31*clm*YMM_SCD1 = 79*clm 64-byte cache lines

;; This pass processes 1024*clm cache lines, or 256KB if clm=4, suggesting we should use clm=1:  64KB of scratch area,
;; 64KB of input FFT data, 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

IFDEF SLOWER_BUT_LESS_SINCOS_MEMORY
	is it because of the 16 reals or is it because of the wpn4 at the lower level
	I suspect it is due to the moved wpn4 as sc512 also uses 16 reals though I don't see why the
		increase in group multipliers would cause a 4% slowdown
yr4dwpn_pass1sc2048 MACRO fftname, pass2_levels, clmarg
	LOCAL	b0b, b1a, b1b, b4b, b5b, b6b, b7a, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	set_FFT_constants fftname, 0, 0, 2048, pass2_levels, clmarg
	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 2048K FFT)

pass2:	start_timer 0
	call	ypass2name
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 9,10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 1 sixteen_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 127 eight_complex_unfft8 operations
;;	distance between fft data elements is 1K
;;	do 31.75 macros each processing 64 data values

;; Do inverse FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 8 eight_reals_unfft operations
;;	distance between fft data elements is 8K
;;	do 2 macro processing 32 data values
;; Do 248 four_complex_unfft operations
;;	distance between fft data elements is 8K
;;	do 62 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 8*clm+48*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 64*4*clm iterations

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD4		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+31*clm*YMM_SCD1+2*4*clm*64] ;; Sin/cos ptr for timer 17
	jmp	c9aa
;;	end_timer 16

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
c9aa:	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	lea	rdx, [rbx-2*4*clm*32]		;; Weights ptr
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; 4*clm iterations, next source ptr, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rbx, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos pointer
c7c:	end_timer 17

	yloop	32, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer

ELSE

	start_timer 16
	yloop_init 32*4*clm			;; 32*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8_preload
c8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr8_rsc_sg8cl_eight_complex_unfft8_preload
c9b:	yr8_rsc_sg8cl_eight_complex_unfft8 rbp, 64, blkdst, 2*blkdst, 4*blkdst, rsi, 256, 64, 128, clmblkdst, rdx, YMM_SCD8, clm, L1PREFETCH_ALL, ((clm MOD 2)+1)*8*blkdst ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	32, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	bump	rdi, 2*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*32]		;; Weights ptr
	yloop_init 32*4*clm			;; 32*4*clm iterations
	yloop_set_clm_prefetch YSINGLE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c6b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source pointer
	yloop	2, c6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c7b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+clmblkdst	;; 4*clm iterations, next source ptr
	yloop	2, c7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Loop, next source ptr, restore sin/cos ptrs
	yloop	32, c7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 32 eight_reals_unfft operations
;;	distance between fft data elements is 32K
;;	do 8 macro processing 32 data values
;; Do 224 four_complex_unfft operations
;;	distance between fft data elements is 32K
;;	do 56 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...

;; Do 128 sixteen_reals_unfft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 128*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 4+12 cache lines of s/c data.
;; A grand total of 38+K bytes with clm=4 -- NOT fitting in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rdi+32*YMM_SCD7]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64 or 32 iters of 4*clm

c4a:	start_timer 18
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+4*clmblkdst8 ;; Test loop counter

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 32 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+4*clmblkdst8 ;; Test loop counter
	yloop	8, c5b, -8*4*clmblkdst8, rbx, YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 8*4*clm
	end_timer 18

	start_timer 20
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD7 ;; Test loop counter
	yloop	8, c1b, -4*clmblkdst8+clmblkdst, rdi, -4*8*YMM_SCD7+YMM_SCD7 ;; 4 iterations!! next source pointer, next sin/cos ptr
	end_timer 20

	yloop	8, c4a				;; Test loop counter

ELSE

	start_timer 18
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 32*YMM_SCD7		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YHALF
	yr4_4cl_csc_eight_reals_unfft_preload
c4b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, c4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 32 blocks
	yr4_4cl_four_complex_djbunfft_preload
c5b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, c5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; 8 iterations, restore sin/cos pointer
	yloop	8, c5b, -8*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 20
	bump	rdi, -32*YMM_SCD7		;; Next fixed sine/cosine pointer
	yloop_init 32*4*clm			;; 32 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 32 blocks
	yr8_8cl_16_reals_unfft_preload
c1b:	yr8_8cl_16_reals_unfft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, c1b				;; 4 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copy_scratch_data_to_fft 256
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copy_fft_data_to_scratch 256

;; Do FFT levels 1,2,3,4
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...

;; Do 128 sixteen_reals_fft operations
;;	distance between fft data elements is 128K
;;	do 32 macros each processing 64 data values

;; Do FFT levels 5,6
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	128K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	124K	...
;;	256K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...

;; Do 32 eight_reals_fft operations
;;	distance between fft data elements is 32K
;;	do 8 macros each processing 32 data values
;; Do 224 four_complex_fft operations
;;	distance between fft data elements is 32K
;;	do 56 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 128*clm cache lines of data (+2/(4*clm) due to ineffective L1 prefetching) + 12+4 cache lines of s/c data.
;; A grand total of 38+K bytes with clm=4 -- NOT fitting in a 32KB L1 cache.
;;    IDEA:  Try prefetching next section into L1 cache  (especially for clm=2)

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	bump	rcx, 128*4*blkdst		;; We've already prefetched 128 blocks

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi+32*YMM_SCD7]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 32 or 64 iters of 4*clm

b1a:	start_timer 22
	yloop_adjust 4*4*clm			;; Do fewer iterations in this loop
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 64 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst8, rdi, 8*YMM_SCD7 ;; 4*clm iters, next source ptr, next sin/cos ptr
	yloop	8, b1b, -4*clmblkdst8, rdi, -4*8*YMM_SCD7+YMM_SCD7 ;; 4 iterations!! restore source pointer, next sin/cos ptr
	loops_undo 8*4*clm
	end_timer 22

	start_timer 24
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b4b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rbx, 0, 4*clm
	yloop	4*clm, b5b, -4*clm*64+4*clmblkdst8 ;; 4*clm iterations
	yloop	8, b5b, -8*4*clmblkdst8+clmblkdst, rbx, YMM_SCD4 ;; Test loop counter, next source pointer, next sin/cos ptr
	end_timer 24

	yloop	8, b1a, -8*clmblkdst		;; Test loop counter, restore source pointer

ELSE

	start_timer 22
	yloop_init 32*4*clm			;; 32 iters of 4*clm
	yloop_set_clm_prefetch YDOUBLE		;; Prefetch 64 blocks
	yr8_8cl_16_reals_fft_preload
b1b:	yr8_8cl_16_reals_fft rsi, 64, 4*clmblkdst8, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD7	;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	4, b1b, -4*clmblkdst8		;; 4 iterations, restore source pointer
	end_timer 22

	start_timer 24
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE
	yr4_4cl_csc_eight_reals_fft_preload
b4b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b4b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b5b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst8, 2*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos ptr
	yloop	8, b5b, -8*clmblkdst+4*clmblkdst8, rdi, -8*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr
	yloop	8, b5b, -8*4*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 7,8
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	32K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	28K	...
;;	64K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...

;; Do 8 eight_reals_fft operations
;;	distance between fft data elements is 8K
;;	do 2 macros each processing 32 data values
;; Do 248 four_complex_fft operations
;;	distance between fft data elements is 8K
;;	do 62 macros each processing 32 data values

;; Do FFT levels 9,10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	8K	+1K	+1K	+1K
;;	4K	...
;;	16K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	8K	+1	+1	+1
;;	1K	...
;;	...
;;	7K	...
;;	16K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 sixteen_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 64 data values
;; Do 127 eight_complex_fft8 operations
;;	distance between fft data elements is 1K
;;	do 31.75 macros each processing 64 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 32*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		32*clm cache lines to output FFT data + 48*clm+8*clm cache lines of s/c data.
;; A grand total of 38912 bytes with clm=4 -- NOT fitting in a 32KB L1 cache.

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdx, PREMULT_ADDR
	bump	rdx, clm*YMM_SCD4+clm*YMM_SCD4+31*clm*YMM_SCD1 ;; Weights ptr
	lea	rdi, [rdx+2*4*clm*64]		;; Sin/cos ptr
	mov	rbp, DATA_ADDR			;; Destination pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 64*4*clm			;; 64 or 32 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr, restore sin/cos ptr
	end_timer 25
	loops_undo 2*4*clm

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rbx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7a:	start_timer 25
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
	yloop_set_prefetch YQUARTER		;; Prefetch 62*clm cache lines
	yloop_set_alternate_prefetch_increment 79, (62+31)
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, clmblkdst8
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 2*4*clm
	end_timer 25

	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	yloop_adjust 4*clm			;; Fewer iterations in this loop
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 31*clm cache lines
	yloop_set_alternate_prefetch_increment 79, (62+31)
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	end_timer 26

	yloop	64, b7a				;; 32 iterations!!!

ELSE

	start_timer 25
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 2*4*clm*64 + clm*YMM_SCD4 + clm*YMM_SCD4 + 31*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-2*4*clm*64]		;; Weights ptr
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b6b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+clmblkdst	;; Test loop counter, next source ptr
	yloop	2, b6b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 62*clm cache lines
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b7b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 2*clmblkdst, 4*clmblkdst, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	2, b7b, -2*clmblkdst+clmblkdst8, rdx, -2*4*clm*32, rdi, -2*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	32, b7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr8_rsc_sg8cl_eight_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD4]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD8 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	yloop_init 32*4*clm			;; 32 iters of 4*clm
pfing	bump	rcx, (79-62-31)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8_preload
b8b:	yr8_rsc_sg8cl_2sc_sixteen_reals_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, rdi, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b8b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9aa

	loops_reset
b9a:	yr8_rsc_sg8cl_eight_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD8 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
b9aa:	yloop_set_prefetch YQUARTER		;; Prefetch 31*clm cache lines
	yr8_rsc_sg8cl_eight_complex_fft8_preload
b9b:	yr8_rsc_sg8cl_eight_complex_fft8 rsi, 256, 64, 128, clmblkdst, rbp, 64, blkdst, 2*blkdst, 4*blkdst, rdx, YMM_SCD8, clm, L1PREFETCH_DEST_ALL, 8*blkdst
	yloop	clm, b9b, -clm*256+2*clmblkdst, rbp, -clm*64+8*blkdst, rdx, -clm*YMM_SCD8 ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b, -4*2*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	32, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 2048 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM
ENDIF


;; Perform a shared pass 1 FFT of length 2048 doubles.
;; Memory examples are for a 2048K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*64 + 4*4*clm*YMM_SCD4 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 15*clm*YMM_SCD1 = 115*clm 64-byte cache lines

;; This pass processes 1024*clm cache lines, or 256KB if clm=4, suggesting we should use clm=1:  64KB of scratch area,
;; 64KB of input FFT data, 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc2048 MACRO
	LOCAL	b0b, b1a, b1b, b2b, b3b, b4b, b5b, b6b, b7a, b7aa, b7b, b8b, b9a, b9aa, b9b
	LOCAL	c0b, c1b, c2b, c3b, c4a, c4b, c5b, c6b, c7a, c7b, c7c, c8b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 2048K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values if pass 2 swizzles:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 1 eight_reals_unfft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 255 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 63.75 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 4 eight_reals_unfft operations
;;	distance between fft data elements is 4K
;;	do 1 macro processing 32 data values
;; Do 252 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 63 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 4*clm+16*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	yloop_init 64*4*clm			;; 64*4*clm iterations
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

	start_timer 16
	mov	rdi, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdi, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD2		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	lea	rbx, [rdi+15*clm*YMM_SCD1]	;; Sin/cos ptr for timer 17
	end_timer 16
	jmp	c9aa

	loops_reset
c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	end_timer 16
c9aa:	start_timer 16
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area pointer
	end_timer 16
	loops_undo 4*clm

	start_timer 17
	cmp	rsi, scratch_area		;; Do reals macro on first iteration, do complex on later iterations
	jne	c7a				;; Do complex macro
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst ;; Prefetch next scratch area section
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	jmp	c7c
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

c7a:	yloop_set_clm_prefetch YSINGLE		;; Prefetch 63 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
c7c:	end_timer 17

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9aa, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9aa				;; Test loop counter, next sin/cos pointer
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD4]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 64*4*clm			;; 64*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4_preload
c8b:	yr4_rsc_sg4clreg_2sc_eight_reals_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, rdi, YMM_SCD2, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	jmp	c9aa

	loops_reset
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
c9aa:	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next src/dest ptrs, restore sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter, next dest pointer
	yloop	2, c9b				;; Test loop counter
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c6b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 63 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	32, c7b, -32*clmblkdst8, rdi, 4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos ptr
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 16 eight_reals_unfft operations
;;	distance between fft data elements is 16K
;;	do 4 macro processing 32 data values
;; Do 240 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 60 macros each processing 32 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 64 eight_reals_unfft operations
;;	distance between fft data elements is 64K
;;	do 16 macro processing 32 data values
;; Do 192 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 48 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...

;; Do 256 eight_reals_unfft operations
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 due to ineffective L1 prefetching) + 24+16+48 cache lines of s/c data.
;; A grand total of 23040 bytes -- should fit in a 32KB L1 cache.

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	mov	rbp, sincos2			;; Load fixed sin/cos data ptr
	lea	rbx, [rbp+64*YMM_SCD3]		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations

c4a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c4b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8, rdx, 4*32, rdi, 4*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointer
	loops_undo 16*4
	end_timer 18

	start_timer 19
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c2b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c2b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, c2b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c2b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 24 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, c3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD3 ;; Test loop counter, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -8*clmblkdst8+4*64, rbp, -16*4*YMM_SCD3 ;; Test loop counter, next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c4a, -clm*4*64+clmblkdst, rbx, YMM_SCD4, rbp, YMM_SCD3 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, c4a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_unfft_preload
c4b:	yr4_b4cl_csc_wpn4_eight_reals_unfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c4b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; 4 iterations, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed sin/cos data ptr
	bump	rdi, 64*YMM_SCD3		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_unfft_preload
c2b:	yr4_4cl_csc_eight_reals_unfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c2b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sin/cos pointer
	yloop	8, c2b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c2b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YHALF		;; Prefetch 24 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations, next sine/cosine pointer
	yloop	8, c3b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; 2 iterations, restore sine/cosine pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -64*YMM_SCD3		;; Next fixed sine/cosine pointer
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_eight_reals_unfft_preload
c1b:	yr4_4cl_eight_reals_unfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, c1b				;; 8 iterations
	end_timer 20
ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 256
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 256

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 eight_reals_fft operations
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 64 eight_reals_fft operations
;;	distance between fft data elements is 64K
;;	do 16 macros each processing 32 data values
;; Do 192 four_complex_fft operations
;;	distance between fft data elements is 64K
;;	do 48 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 16 eight_reals_fft operations
;;	distance between fft data elements is 16K
;;	do 4 macros each processing 32 data values
;; Do 240 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 60 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 or +1/8 due to ineffective L1 prefetching) + 48+16+24 cache lines of s/c data.
;; A grand total of 23040 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, (151-3)*4	;; We've already prefetched 151 blocks which will be 3 too many
pfing	add	rcx, rax

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed sin/cos postmultipliers
	lea	rbx, [rbp+64*YMM_SCD3]		;; Sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 15*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YNONE
	yr4_4cl_eight_reals_fft_preload
	mov	r9, 4*clmblkdst			;; A short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, r9 ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD3 ;; Test loop counter, next sin/cos ptr
	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b1b, -8*clmblkdst8, rbp, -16*4*YMM_SCD3 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b2b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b2b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, b2b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b2b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD4 ;; Test loop counter, next sin/cos pointer
	yloop	2, b3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4
	yloop	4, b4b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointers

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 60 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD4 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*2*clmblkdst8+4*64, rdx, 4*32, rdi, 4*YMM_SCD4 ;; Test loop counter, restore source pointer, next sin/cos pointers
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD4, rbp, YMM_SCD3 ;; Test loop counter, next source pointer, next sin/cos pointers
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*64-4*clm*4*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed sin/cos postmultipliers
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_eight_reals_fft_preload
b1b:	yr4_4cl_eight_reals_fft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD3 ;; 4*clm iters
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, b1b, -8*clmblkdst8		;; 8 iterations, restore source pointer
	end_timer 22

	start_timer 23
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_4cl_csc_eight_reals_fft_preload
b2b:	yr4_4cl_csc_eight_reals_fft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b2b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b2b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b2b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, restore sin/cos ptr

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 48 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD4 ;; 4*clm iterations
	yloop	8, b3b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of premultiplier/sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD4 + clm*YMM_SCD2 + clm*YMM_SCD2 + 15*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_csc_wpn4_eight_reals_fft_preload
b4b:	yr4_b4cl_csc_wpn4_eight_reals_fft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b4b, -4*clm*64+clmblkdst ;; Test loop counter, next source ptr
	yloop	4, b4b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptrs

	loops_reset
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 60 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	16, b5b, -16*2*clmblkdst8, rdi, -4*4*clm*64 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 4 eight_reals_fft operations
;;	distance between fft data elements is 4K
;;	do 1 macros each processing 32 data values
;; Do 252 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 63 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 1 eight_reals_fft operations
;;	distance between fft data elements is 1K
;;	do 0.25 macros each processing 32 data values
;; Do 255 four_complex_fft4 operations
;;	distance between fft data elements is 1K
;;	do 63.75 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 16*clm+4*clm cache lines of s/c data.
;; A grand total of 17408 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD4		;; Premultiplier/sin/cos ptr
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).
	yloop_init 64*4*clm			;; 64 iterations of 4*clm

	start_timer 25
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 4*clmblkdst
	yloop	4*clm, b6b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source ptr. restore sin/cos ptr
	end_timer 25
	loops_undo 4*clm

	start_timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rbx, [rdx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, rbx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	jmp	b9a				;; Do remaining complex macro calls
	loops_reset				;; Dummy loops_reset so that next section prefetches properly

b7aa:	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	end_timer 26

b7a:	start_timer 25
	yloop_set_prefetch YQUARTER		;; Prefetch 63*clm cache lines
	yloop_set_alternate_prefetch_increment 115, (63+64)
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, r9
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
b9a:	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 115, (63+64)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a				;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b7aa			;; Test loop counter

ELSE

pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	start_timer 25
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_4cl_csc_eight_reals_fft_preload
b6b:	yr4_4cl_csc_eight_reals_fft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b6b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source ptr, restore sin/cos ptr

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 63*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD4, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD4 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	32, b7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos_simple rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Real data sin/cos pointer, will become delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_prefetch YNONE		;; Prefetch no cache lines
	yr4_rsc_sg4clreg_2sc_eight_reals_fft4_preload
b8b:	yr4_rsc_sg4clreg_2sc_eight_reals_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdi, YMM_SCD4, rdx, YMM_SCD2, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b8b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdi, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer

	loops_reset
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
pfing	bump	rcx, (115-63-64)*clm*64		;; Finish prefetching the sin/cos/premult data
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b				;; Test loop counter, next premult/sine/cosine pointer
	yloop	16, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 2048 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM


;; Perform a shared pass 1 negacyclic FFT of length 2048 doubles.
;; Memory examples are for a 2048K FFT with 10 levels done in pass 2.
;; Sin/cos data needed: 4*4*clm*64 + 4*4*clm*YMM_SCD2 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 = 74*clm 64-byte cache lines

;; This pass processes 1024*clm cache lines, or 256KB if clm=4, suggesting we should use clm=1:  64KB of scratch area, 64KB of input FFT data,
;; 64KB of prefetched FFT data, plus s/c data.  This might just barely fit in 256KB L2 cache.
;; Actual results, show that clm=4 is better than clm=2 which is vastly better than clm=1 -- I have no idea why.

yr4dwpn_pass1sc2048ac MACRO
	LOCAL	b0b, b1a, b1b, b3b, b5b, b7a, b7aa, b7b, b9a, b9b, c0b, c1b, c3b, c5a, c5b, c7b, c9a, c9aa, c9b
	LOCAL	pass1, pass2, endlp, done, yes_fft

	yfft_header pass1

;; Do pass 2 (the last 10 FFT levels if this is a 2048K FFT)

pass2:	start_timer 0
	mov	rax, YMM_PASS2_ROUTINE
	call	rax
	end_timer 0
	cmp	ffttype, 1		;; We're done if FFTing only
	je	done

;; Do the inverse FFT

	pass1_inverse_fft_setup c0b

;; Do inverse FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; The output cache lines are swizzled to hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 256 four_complex_unfft4 operations
;;	distance between fft data elements is 1K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 4K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines of input FFT data + 4*clm+8*clm cache lines of s/c data.
;; A grand total of 15360 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

c0b:	mov	rbp, DATA_ADDR			;; Get source address
	mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
	lea	r12, [rbp+((clm MOD 2)+1)*4*blkdstreg] ;; L1 prefetch pointer

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rdi, PREMULT_ADDR		;; Load premult/sin/cos pointer
	bump	rdi, clm*YMM_SCD2		;; Delayed sin/cos multipliers
	lea	rbx, [rdi+16*clm*YMM_SCD1]	;; Sin/cos ptr for timer 17
	yloop_init 64*4*clm			;; 64*4*clm iterations
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

c9a:	start_timer 16
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos pointer
	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	end_timer 16
c9aa:	start_timer 16
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	4, c9b, -4*clmblkdst		;; Test loop counter, restore scratch area ptr
	loops_undo 4*clm
	end_timer 16

	start_timer 17
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rbx, YMM_SCD2, 4*clm, L1PREFETCH_ALL, r9 ;; Prefetch next scratch area section
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rbx, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	end_timer 17

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, c9aa, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9aa				;; Test loop counter
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	lea	rdi, [rbx+4*clm*YMM_SCD2]	;; Next sin/cos ptr

ELSE

	start_timer 16
	yloop_init 64*4*clm			;; 64*4*clm iterations
	mov	rbx, PREMULT_ADDR		;; Complex data sin/cos ptr
	lea	rdi, [rbx+clm*YMM_SCD2]		;; Delayed sin/cos multipliers
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_clm_prefetch YNONE
c9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed sin/cos multipliers
	yr4_rsc_sg4clreg_four_complex_unfft4_preload
c9b:	yr4_rsc_sg4clreg_four_complex_unfft4 rbp, 64, blkdstreg, blkdst3reg, rsi, 256, 64, 128, rdx, YMM_SCD4, clm, L1PREFETCH_ALL, r12 ;; Prefetch short dist ahead
	yloop	clm, c9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next dest/src ptrs, restore premult/sin/cos ptr
	yloop	8, c9b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, c9b				;; Test loop counter
	yloop	16, c9a, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 16

	start_timer 17
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c7b:	yr4_4cl_four_complex_djbunfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointer
	yloop	2, c7b, -2*4*clmblkdst+clmblkdst8 ;; 2 iterations, next source pointer
	yloop	32, c7b, -32*clmblkdst8, rdi, 4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos pointer
	end_timer 17

ENDIF

;; Do inverse FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do inverse FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...

;; Do 256 four_complex_unfft operations
;;	distance between fft data elements is 256K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 due to ineffective L1 prefetching) + 12+8+96 cache lines of s/c data.
;; A grand total of 24832 bytes -- should fit in a 32KB L1 cache.

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+64*YMM_SCD6]		;; Second sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations

c5a:	start_timer 18
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4, L1PREFETCH_ALL, 2*clmblkdst8 ;; Prefetch short dist ahead
	yloop	4, c5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer
	yloop	16, c5b, -16*2*clmblkdst8, rdx, 4*32, rdi, 4*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptr
	loops_undo 16*4
	end_timer 18

	start_timer 19
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, c3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	2, c3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 19

	start_timer 20
	yloop_set_clm_prefetch YNONE
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4
	yloop	4, c1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; 4 iterations, next sin/cos ptr
	yloop	2, c1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, c1b, -8*clmblkdst8+4*64, rbp, -16*4*YMM_SCD6 ;; Test loop counter, next source pointer, restore sin/cos ptr
	end_timer 20

	yloop	clm, c5a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, c5a				;; Test loop counter

ELSE

	start_timer 18
	bump	rdi, 4*4*clm*64			;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*32]		;; Weights ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YNONE
	yr4_b4cl_wpn4_four_complex_djbunfft_preload
c5b:	yr4_b4cl_wpn4_four_complex_djbunfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c5b, -4*clm*64+clmblkdst ;; 4*clm iterations
	yloop	4, c5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD2 ;; 4*clm iterations, restore sin/cos pointers
	yloop	16, c5b, -16*2*clmblkdst8	;; Test loop counter, restore source pointer
	end_timer 18

	start_timer 19
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	bump	rdi, 64*YMM_SCD6		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64*4*clm iterations
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbunfft_preload
c3b:	yr4_4cl_four_complex_djbunfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos data
	yloop	8, c3b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	2, c3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD2 ;; 2 iterations, restore sin/cos pointer
	yloop	4, c3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 19

	start_timer 20
	bump	rdi, -64*YMM_SCD6		;; Sin/cos ptr
	yloop_init 64*4*clm			;; 64 iterations of 4*clm
	yloop_set_clm_prefetch YNONE
c1b:	yr4_4cl_csc_four_complex_last_djbunfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, c1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iterations
	yloop	8, c1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, c1b				;; 8 iterations
	end_timer 20

ENDIF

;; Normalize these values

	pass1_normalize 1, yes_fft

;; Copy data from the scratch area back to the FFT data area

	copyreg_scratch_data_to_fft 256
	jmp	endlp			;; Skip FFT code if flag not set

;; Fire up auxiliary threads to do pass 1 forward FFT

pass1:	pass1_forward_fft_setup b0b

;; Copy data from the FFT data area back to the scratch area

b0b:	copyreg_fft_data_to_scratch 256

;; Do FFT levels 1,2,3
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	1024K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	1020K	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...

;; Do 256 four_complex_first_fft operations
;;	distance between fft data elements is 256K
;;	do 64 iterations each processing 32 data values

;; Do FFT levels 4,5
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	256K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	252K	...
;;	512K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 64K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 6,7
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	64K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	60K	...
;;	128K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 16K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 256 cache lines of data (+1/16 or +1/8 due to ineffective L1 prefetching) + 96+8+12 cache lines of s/c data.
;; A grand total of 24832 bytes -- should fit in a 32KB L1 cache.

yes_fft:mov	rsi, scratch_area		;; Get address of scratch area
	set_data_prefetch_ptrs			;; Init prefetching pointers
pfing	mov	r8, pass2blkdst			;; blkdst
pfing	imul	rax, blkdstreg, 128*4		;; We've already prefetched 128 blocks
pfing	add	rcx, rax

IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	mov	rbp, sincos2			;; Load fixed premultiplier/sin/cos ptr
	lea	rbx, [rbp+64*YMM_SCD6]		;; Second sin/cos ptr
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 ;; Third sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm

b1a:	start_timer 22
	yloop_set_clm_prefetch YNONE
	mov	r9, 4*clmblkdst			;; A short distance ahead in the scratch area (so we can prefetch it into the L1 cache).
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rbp, 0, 4, L1PREFETCH_ALL, r9 ;; Prefetch a short distance ahead
	yloop	4, b1b, -4*64+4*clmblkdst, rbp, 4*YMM_SCD6 ;; Test loop counter, next sin/cos ptr
	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b1b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	8, b1b, -8*clmblkdst8, rbp, -16*4*YMM_SCD6 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 16*4
	end_timer 22

	start_timer 23
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rbx, 0, 4
	yloop	4, b3b, -4*64+4*clmblkdst, rbx, 4*YMM_SCD2 ;; Test loop counter, next sin/cos pointer
	yloop	2, b3b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rbx, -4*4*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos pointer
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	loops_undo 4*4*4
	end_timer 23

	start_timer 24
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4
	yloop	4, b5b, -4*64+2*clmblkdst8, rdx, -4*32, rdi, -4*YMM_SCD2 ;; Test loop counter, restore sin/cos pointer
	yloop	16, b5b, -16*2*clmblkdst8+4*64, rdx, 4*32, rdi, 4*YMM_SCD2 ;; Test loop counter, restore source pointer, next sin/cos ptrs
	end_timer 24

	yloop	clm, b1a, -clm*4*64+clmblkdst, rbx, YMM_SCD2, rbp, YMM_SCD6 ;; Test loop counter, next source pointer, next sin/cos ptrs
	yloop	4, b1a, -4*clmblkdst, rdi, -4*4*clm*64-4*clm*4*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr

ELSE

	start_timer 22
	mov	rdi, sincos2			;; Load fixed premultiplier/sin/cos ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YNONE
b1b:	yr4_4cl_csc_four_complex_first_djbfft rsi, 64, 8*clmblkdst8, 16*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b1b, -4*clm*64+clmblkdst, rdi, YMM_SCD6 ;; 4*clm iters prefetching 4*clm cache lines
	yloop	8, b1b, -8*clmblkdst+clmblkdst8 ;; 8 iterations
	yloop	8, b1b, -8*clmblkdst8		;; 8 iterations
	end_timer 22

	start_timer 23
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_4cl_four_complex_djbfft_preload
b3b:	yr4_4cl_four_complex_djbfft rsi, 64, 2*clmblkdst8, 4*clmblkdst8, rdi, 0, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b3b, -4*clm*64+clmblkdst, rdi, YMM_SCD2 ;; 4*clm iterations, next sin/cos pointer
	yloop	8, b3b, -8*clmblkdst+clmblkdst8 ;; Test loop counter
	yloop	2, b3b, -2*clmblkdst8+8*clmblkdst8, rdi, -16*YMM_SCD2 ;; Test loop counter, restore sin/cos ptr
	yloop	4, b3b, -4*8*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 23

	start_timer 24
	mov	rdi, PREMULT_ADDR		;; Address of sin/cos table
	bump	rdi, 4*4*clm*64 + 4*clm*YMM_SCD2 + clm*YMM_SCD2 + 16*clm*YMM_SCD1 ;; Sin/cos ptr
	lea	rdx, [rdi-4*4*clm*64]		;; Weights ptr
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	yloop_set_clm_prefetch YSINGLE		;; Prefetch 64 blocks
	yr4_b4cl_wpn4_four_complex_djbfft_preload
b5b:	yr4_b4cl_wpn4_four_complex_djbfft rsi, 64, 4*clmblkdst, clmblkdst8, rdx, 32, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64 ;; Prefetch short dist ahead
	yloop	4*clm, b5b, -4*clm*64+clmblkdst	;; Test loop counter, next source pointer
	yloop	4, b5b, -4*clmblkdst+2*clmblkdst8, rdx, -4*4*clm*32, rdi, -4*4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptrs
	yloop	16, b5b, -16*2*clmblkdst8, rdi, -4*4*clm*64 ;; Test loop counter, restore source pointer
	end_timer 24

ENDIF

;; Do FFT levels 8,9
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	16K	+1K	+1K	+1K
;;	4K	...
;;	...
;;	12K	...
;;	32K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 4K
;;	do 64 macros each processing 32 data values

;; Do FFT levels 10,11
;; On input the 64-byte cache lines hold these data values:
;;	0K	+1K	+1K	+1K	4K	+1K	+1K	+1K
;;	8K	...
;;	...
;; The input is swizzled to hold these data values:
;;	0K	+1	+1	+1	4K	+1	+1	+1
;;	1K	...
;;	...
;;	3K	...
;;	8K	...
;;	...
;; On output the 64-byte cache lines hold these data values:
;;	0K	+1	+1	+1	1K	+1	+1	+1
;;	2K	...
;;	...

;; Do 256 four_complex_fft operations
;;	distance between fft data elements is 1K
;;	do 64 macros each processing 32 data values

;; Process data in small chunks for more L1 data cache hits
;; This section processes chunks of 16*clm cache lines of scratch area data (+100% due to L1 prefetching next section) +
;;		16*clm cache lines to output FFT data + 8*clm+4*clm cache lines of s/c data.
;; A grand total of 15360 bytes with clm=4 -- easily fitting in a 32KB L1 cache.

	bump	rdi, -4*clm*YMM_SCD2		;; First sin/cos ptr (for timer 25)

	mov	r8, pass2blkdst			;; blkdst
	lea	r10, [2*blkdstreg+blkdstreg]	;; 3*blkdst
IF (256*4*clm*64 GT GROUPING_SIZE) OR (clm GE CLM_GROUPING)

	lea	rbx, [rdi-16*clm*YMM_SCD1]	;; Delayed multipliers for timer 26
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_init 64*4*clm			;; 64 iters of 4*clm
	mov	r9, 4*clmblkdst			;; Distance to the next portion of the scratch area we will process (so we can prefetch it into the L1 cache).

b7aa:	start_timer 26
	mov	rdx, PREMULT_ADDR		;; Complex data sin/cos ptr
	yr4_rsc_sg4cl_four_complex_calc_sincos rbx, rdx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rbx, clm*YMM_SCD1		;; Next set of delayed multipliers
	end_timer 26

b7a:	start_timer 25
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 74, (64+64)
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, r9
	yloop	4*clm, b7b, -4*clm*64, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, restore source pointer, restore sin/cos ptr
	loops_undo 4*clm
	end_timer 25

	start_timer 26
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yloop_set_alternate_prefetch_increment 74, (64+64)
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	4, b9b				;; Test loop counter
	end_timer 26

	xor	r9, (clmblkdst8-4*clmblkdst) XOR (4*clmblkdst) ;; "Toggle" the distance to next scratch area
	yloop	2, b7a, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	2, b7a				;; Test loop counter
	yloop	16, b7aa			;; Test loop counter

ELSE

	start_timer 25
	yloop_init 64*4*clm			;; 64 iters of 4*clm
pfing	mov	rcx, PREMULT_PREFETCH		;; Load premult/sin/cos prefetch pointer
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
	yr4_4cl_four_complex_djbfft_preload
b7b:	yr4_4cl_four_complex_djbfft rsi, 64, clmblkdst, 2*clmblkdst, rdi, YMM_SCD2, 4*clm, L1PREFETCH_ALL, 2*64
	yloop	4*clm, b7b, -4*clm*64+4*clmblkdst, rdi, -4*clm*YMM_SCD2 ;; Test loop counter, next source pointer, restore sin/cos ptr
	yloop	2, b7b, -2*4*clmblkdst+clmblkdst8 ;; Test loop counter, next source pointer
	yloop	32, b7b, -32*clmblkdst8		;; Test loop counter, restore source pointer
	end_timer 25

	start_timer 26
	bump	rdi, -16*clm*YMM_SCD1		;; Delayed sin/cos multipliers
	lea	rbx, [rdi-clm*YMM_SCD2]		;; Complex data sin/cos ptr (a.k.a. PREMULT_ADDR)
	lea	rdx, YMM_TMPS			;; Computed clm*SCD4 sin/cos values
	mov	rbp, DATA_ADDR			;; Destination pointer
	lea	r12, [rbp+4*blkdstreg]		;; L1 prefetch pointer
	yloop_init 64*4*clm			;; 64 iters of 4*clm
pfing	bump	rcx, (74-64-64)*clm*64		;; Finish prefetching the sin/cos/premult data
	yloop_set_prefetch YQUARTER		;; Prefetch 64*clm cache lines
b9a:	yr4_rsc_sg4cl_four_complex_calc_sincos rdi, rbx, clm ;; Generate clm*SCD4 sin/cos values from delayed and complex multipliers
	bump	rdi, clm*YMM_SCD1		;; Next set of delayed multipliers
	yr4_rsc_sg4clreg_four_complex_fft4_preload
b9b:	yr4_rsc_sg4clreg_four_complex_fft4 rsi, 256, 64, 128, rbp, 64, blkdstreg, blkdst3reg, rdx, YMM_SCD4, clm, L1PREFETCH_DEST_ALL, r12
	yloop	clm, b9b, -clm*256+clmblkdst, rbp, -clm*64+4*blkdstreg, rdx, -clm*YMM_SCD4, r12, -clm*64+4*blkdstreg ;; Loop, next source/dest pointers, restore premult/sine/cosine pointer
	yloop	8, b9b, -8*clmblkdst+clmblkdst8	;; Test loop counter, next source pointer
	yloop	2, b9b				;; Test loop counter
	yloop	16, b9a				;; Test loop counter
	end_timer 26

ENDIF

;; Work on next 4*clm sets of 2048 values

endlp:	ypass1_get_next_block pass2, c0b, b0b ;; Get next block and jump
done:	yfft_footer
	ENDM

ENDIF
